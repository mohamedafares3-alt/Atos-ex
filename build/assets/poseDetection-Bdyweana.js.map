{"version":3,"file":"poseDetection-Bdyweana.js","sources":["../../src/utils/poseDetection.js"],"sourcesContent":["// Pose detection utilities using MediaPipe\nclass PoseDetectionUtils {\n  constructor() {\n    this.pose = null;\n    this.isInitialized = false;\n  // Per-exercise state to avoid cross-contamination between different exercises\n  // Structure: { <mode>: { state: 'up'|'down'|'neutral'|..., count: number, extra... } }\n  this.perModeState = {};\n  const initMode = (mode) => ({ state: 'up', count: 0 });\n  this.perModeState['pushups'] = initMode('pushups');\n  this.perModeState['squats'] = initMode('squats');\n  this.perModeState['lunges'] = initMode('lunges');\n  this.perModeState['burpees'] = initMode('burpees');\n  this.perModeState['mountainclimbers'] = { state: 'neutral', count: 0, _lastLeftKneeY: null, _lastRightKneeY: null, _climberState: 'neutral', _lastClimberTime: 0 };\n  this.perModeState['highknees'] = { state: 'down', count: 0 };\n  this.perModeState['jumpingjacks'] = { state: 'down', count: 0 };\n  this.perModeState['sideplank'] = { state: 'neutral', count: 0 };\n    this.postureStatus = 'unknown'; // correct, incorrect, unknown\n    this.lastWarningTime = 0;\n    this.videoDimensionsLogged = false;\n    // Exercise mode and timing\n    this.exerciseMode = 'pushups'; // 'pushups' | 'plank' | 'squats' | 'lunges'\n    this.accumulatedCorrectMs = 0;\n    this.timerRunning = false;\n    this.startCorrectTimestampMs = 0;\n    this.onPushupCount = null;\n    this.onPostureChange = null;\n    this.onFormFeedback = null;\n    this.onTimeUpdate = null; // for plank seconds updates\n  }\n\n  setExerciseMode(mode) {\n    // ensure perModeState exists for the selected mode\n    if (!this.perModeState[this.exerciseMode]) {\n      this.perModeState[this.exerciseMode] = { state: 'up', count: 0 };\n    }\n    const normalized = String(mode || '').toLowerCase();\n    if (normalized === 'plank') this.exerciseMode = 'plank';\n    else if (normalized === 'squats' || normalized === 'squat') this.exerciseMode = 'squats';\n    else if (normalized === 'lunges' || normalized === 'lunge') this.exerciseMode = 'lunges';\n    else if (normalized === 'burpees' || normalized === 'burpee') this.exerciseMode = 'burpees';\n    else if (normalized.includes('mountain') || normalized.includes('climber')) this.exerciseMode = 'mountainclimbers';\n    else if (normalized.includes('high') && normalized.includes('knees')) this.exerciseMode = 'highknees';\n    else if (normalized.includes('jumping') && normalized.includes('jack')) this.exerciseMode = 'jumpingjacks';\n    else if (normalized.includes('side') && normalized.includes('plank')) this.exerciseMode = 'sideplank';\n    else this.exerciseMode = 'pushups';\n  }\n\n  // Initialize MediaPipe Pose\n  async initialize() {\n    try {\n      console.log('üöÄ Initializing MediaPipe Pose...');\n      \n      // Wait for MediaPipe to load if not ready\n      if (!window.Pose) {\n        console.warn('MediaPipe Pose not loaded yet, waiting...');\n        // Wait up to 10 seconds for MediaPipe to load\n        let attempts = 0;\n        while (!window.Pose && attempts < 50) {\n          await new Promise(resolve => setTimeout(resolve, 200));\n          attempts++;\n          if (attempts % 10 === 0) {\n            console.log(`Still waiting for MediaPipe... (${attempts * 200}ms)`);\n          }\n        }\n        \n        if (!window.Pose) {\n          console.error('MediaPipe Pose failed to load after waiting');\n          return false;\n        }\n      }\n      \n      console.log('‚úÖ MediaPipe Pose found in window object');\n\n      this.pose = new window.Pose({\n        locateFile: (file) => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n        }\n      });\n\n      const config = window.MediaPipeConfig?.POSE_CONFIG || {\n        modelComplexity: 0,\n        smoothLandmarks: true,\n        enableSegmentation: false,\n        smoothSegmentation: false,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      };\n\n      this.pose.setOptions(config);\n      this.pose.onResults(this.onResults.bind(this));\n      \n      this.isInitialized = true;\n      console.log('MediaPipe Pose initialized successfully');\n      return true;\n    } catch (error) {\n      console.error('Failed to initialize MediaPipe Pose:', error);\n      return false;\n    }\n  }\n\n  // Process video frame\n  async processFrame(videoElement) {\n    if (!this.isInitialized || !this.pose) {\n      console.log('‚ùå Pose not initialized or missing');\n      return null;\n    }\n\n    try {\n      // Only log occasionally to avoid spam\n      if (Math.random() < 0.05) {\n        console.log('üìπ Processing frame...');\n      }\n      \n      // Check if video dimensions are reasonable\n      if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {\n        if (Math.random() < 0.1) {\n          console.log('‚è≥ Video dimensions not ready yet');\n        }\n        return;\n      }\n      \n      // Log video dimensions only once per session\n      if (!this.videoDimensionsLogged) {\n        console.log(`üìè Video dimensions: ${videoElement.videoWidth}x${videoElement.videoHeight}`);\n        this.videoDimensionsLogged = true;\n      }\n      \n      // Allow larger videos but with a reasonable limit\n      const maxWidth = 1920;\n      const maxHeight = 1080;\n      if (videoElement.videoWidth > maxWidth || videoElement.videoHeight > maxHeight) {\n        console.log('‚ö†Ô∏è Video too large (>1920x1080), skipping frame');\n        return;\n      }\n      \n      await this.pose.send({ image: videoElement });\n    } catch (error) {\n      if (error.message?.includes('memory access out of bounds')) {\n        console.warn('üîÑ Memory error, skipping frame');\n        return;\n      }\n      console.error('Error processing frame:', error);\n    }\n  }\n\n  // Handle pose detection results\n  onResults(results) {\n    console.log('üéØ onResults called!', results.poseLandmarks ? `Found ${results.poseLandmarks.length} landmarks` : 'No landmarks');\n    \n    // Store results for drawing\n    this.lastResults = results;\n    \n    if (!results.poseLandmarks) {\n      this.postureStatus = 'unknown';\n      if (this.onPostureChange) {\n        this.onPostureChange('unknown', null);\n      }\n      // Stop plank timer if running\n      if (this.timerRunning) {\n        this.accumulatedCorrectMs += Date.now() - this.startCorrectTimestampMs;\n        this.timerRunning = false;\n        this.startCorrectTimestampMs = 0;\n        if (this.onTimeUpdate) {\n          this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n        }\n      }\n      return;\n    }\n\n    const landmarks = results.poseLandmarks;\n    \n    // Evaluate posture for the current exercise using the unified checker.\n    // Use a short consecutive-frame smoothing window to avoid brief spikes flipping posture state\n    const isPostureCorrectInstant = this.checkBackAlignment(landmarks);\n\n    // Initialize counters if missing\n    if (this._postureGoodCount == null) this._postureGoodCount = 0;\n    if (this._postureBadCount == null) this._postureBadCount = 0;\n\n    if (isPostureCorrectInstant) {\n      this._postureGoodCount += 1;\n      this._postureBadCount = 0;\n    } else {\n      this._postureBadCount += 1;\n      this._postureGoodCount = 0;\n    }\n\n  const POSTURE_GOOD_FRAMES = window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_GOOD_FRAMES ?? 3;\n  // For squats we require more consecutive bad frames before flipping to 'incorrect' to avoid\n  // false positives during normal descent. Default to 6 for squats, 4 otherwise.\n  const POSTURE_BAD_FRAMES = (this.exerciseMode === 'squats') ? (window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_BAD_FRAMES ?? 6) : (window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_BAD_FRAMES ?? 4);\n\n    let smoothedStatus = this.postureStatus;\n    if (this._postureGoodCount >= POSTURE_GOOD_FRAMES) {\n      smoothedStatus = 'correct';\n    } else if (this._postureBadCount >= POSTURE_BAD_FRAMES) {\n      smoothedStatus = 'incorrect';\n    }\n\n    // For squats we don't want to show poor/incorrect posture feedback ‚Äî treat as correct.\n    if (this.exerciseMode === 'squats') {\n      smoothedStatus = 'correct';\n    }\n\n    if (smoothedStatus !== this.postureStatus) {\n      this.postureStatus = smoothedStatus;\n      if (this.onPostureChange) this.onPostureChange(this.postureStatus, landmarks);\n    }\n\n    // If posture is incorrect for strength/technique exercises, warn and normally skip counting.\n    // However, allow deep squat descents (hip below knee) to proceed to the squat counter so\n    // counting can occur if legs are stable. The squat counter itself still enforces stability\n    // and collapse checks.\n    const cardioExercises = ['mountainclimbers', 'highknees'];\n\n    // Compute hip/knee centers to detect a deep squat descent (hip below knee)\n    const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n    const leftHip = landmarks[cfg.LEFT_HIP || 23];\n    const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n    const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n    const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n    const hipCenter = leftHip && rightHip ? { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 } : null;\n    const kneeCenter = leftKnee && rightKnee ? { x: (leftKnee.x + rightKnee.x) / 2, y: (leftKnee.y + rightKnee.y) / 2 } : null;\n    const hipBelowKnee = hipCenter && kneeCenter ? (hipCenter.y > kneeCenter.y) : false;\n\n  // Do not emit posture warnings or block counting for squats; allow squat-specific logic to handle counting.\n  if (this.postureStatus !== 'correct' && !cardioExercises.includes(this.exerciseMode) && this.exerciseMode !== 'squats') {\n      const currentTime = Date.now();\n      const cooldown = window.MediaPipeConfig?.PLANK_CONFIG?.WARNING_COOLDOWN || 2000;\n\n      if (currentTime - this.lastWarningTime > cooldown) {\n        this.playWarningSound();\n        this.lastWarningTime = currentTime;\n\n        if (this.onFormFeedback) {\n          this.onFormFeedback({\n            message: \"Dangerous posture - straighten your back!\",\n            type: \"warning\",\n            timestamp: currentTime\n          });\n        }\n      }\n\n      // Stop plank timer while incorrect\n      if (this.exerciseMode === 'plank' && this.timerRunning) {\n        this.accumulatedCorrectMs += currentTime - this.startCorrectTimestampMs;\n        this.timerRunning = false;\n        this.startCorrectTimestampMs = 0;\n        if (this.onTimeUpdate) {\n          this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n        }\n      }\n\n      // Do not proceed to rep counting when posture is incorrect for non-cardio exercises\n      return;\n    }\n\n    // Posture is correct\n    if (this.exerciseMode === 'plank') {\n      const now = Date.now();\n      if (!this.timerRunning) {\n        this.startCorrectTimestampMs = now;\n        this.timerRunning = true;\n      }\n      const totalMs = this.accumulatedCorrectMs + (now - (this.startCorrectTimestampMs || now));\n      const seconds = Math.floor(totalMs / 1000);\n      if (this.onTimeUpdate) this.onTimeUpdate(seconds);\n      return;\n    }\n\n    // Count reps depending on mode\n      if (this.exerciseMode === 'squats') {\n        this.updateSquatCounter(landmarks);\n      } else if (this.exerciseMode === 'lunges') {\n        this.updateLungesCounter(landmarks);\n      } else if (this.exerciseMode === 'burpees') {\n        this.updateBurpeesCounter(landmarks);\n      } else if (this.exerciseMode === 'mountainclimbers') {\n        this.updateMountainClimbersCounter(landmarks);\n      } else if (this.exerciseMode === 'highknees') {\n        this.updateHighKneesCounter(landmarks);\n      } else if (this.exerciseMode === 'jumpingjacks') {\n        this.updateJumpingJacksCounter(landmarks);\n      } else if (this.exerciseMode === 'sideplank') {\n        this.updateSidePlankCounter(landmarks);\n      } else {\n        this.updatePushupCounter(landmarks);\n      }\n  }\n\n  // Calculate angle between three points\n  calculateAngle(point1, point2, point3) {\n    const radians = Math.atan2(point3.y - point2.y, point3.x - point2.x) - \n                   Math.atan2(point1.y - point2.y, point1.x - point2.x);\n    let angle = Math.abs(radians * 180.0 / Math.PI);\n    \n    if (angle > 180.0) {\n      angle = 360 - angle;\n    }\n    \n    return angle;\n  }\n\n  // Detect stable push-up start pose: torso roughly horizontal and ankles visible (proxy for being on toes)\n  isPushupStartPose(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftAnkle) || !vis(rightAnkle)) {\n        return false;\n      }\n\n      const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;\n      const hipCenterY = (leftHip.y + rightHip.y) / 2;\n\n      // torso vertical difference small -> near horizontal\n      const torsoDy = Math.abs(shoulderCenterY - hipCenterY);\n      const THRESH = window.MediaPipeConfig?.PUSHUP_CONFIG?.START_TORSO_DY ?? 0.08;\n      if (torsoDy > THRESH) return false;\n\n      // ankles visible and reasonably below hips (on toes) as an extra proxy\n      const ankleBelowHip = ((leftAnkle.y + rightAnkle.y) / 2) > hipCenterY;\n      if (!ankleBelowHip) return false;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Detect stable squat start pose: standing upright with hips above knees and torso approximately vertical\n  isSquatStartPose(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      // Require shoulders, hips and knees for a reliable standing start pose.\n      // Ankles are optional because many webcams/cameras crop the feet.\n      if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftKnee) || !vis(rightKnee)) {\n        return false;\n      }\n\n      const hipY = (leftHip.y + rightHip.y) / 2;\n      const kneeY = (leftKnee.y + rightKnee.y) / 2;\n      // In normalized coordinates hip above knee when standing\n      const gap = kneeY - hipY; // positive when hip above knee\n  const GAP_MIN = window.MediaPipeConfig?.SQUAT_CONFIG?.START_HIP_KNEE_GAP ?? 0.01;\n      if (gap < GAP_MIN) return false;\n\n      // Torso should be roughly vertical when standing\n      const shoulderCenter = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n      const hipCenter = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      const dx = shoulderCenter.x - hipCenter.x;\n      const dy = shoulderCenter.y - hipCenter.y;\n      const angDeg = Math.abs(Math.atan2(dx, -dy) * 180 / Math.PI); // similar to torso tilt in squat logic\n  const MIN_VERT = window.MediaPipeConfig?.SQUAT_CONFIG?.STANDING_TORSO_MIN_DEG ?? 60;\n  const MAX_VERT = window.MediaPipeConfig?.SQUAT_CONFIG?.STANDING_TORSO_MAX_DEG ?? 120;\n      if (angDeg < MIN_VERT || angDeg > MAX_VERT) return false;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Check back alignment for posture\n  checkBackAlignment(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      \n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      // Require visibility. For plank allow side-view (one side) visibility; for other exercises require both sides for stability.\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      if (this.exerciseMode === 'plank') {\n        const leftSideOk = vis(leftShoulder) && vis(leftHip);\n        const rightSideOk = vis(rightShoulder) && vis(rightHip);\n        if (!leftSideOk && !rightSideOk) {\n          // Not enough landmarks to evaluate plank reliably\n          return false;\n        }\n      } else if (this.exerciseMode === 'pushups') {\n        // For push-ups we only require both shoulders and hips to be visible.\n        if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip)) {\n          return false;\n        }\n      } else {\n        // For other exercises require knees visible for stability\n        if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftKnee) || !vis(rightKnee)) {\n          return false;\n        }\n      }\n\n      // Calculate center points\n      const shoulderCenter = {\n        x: (leftShoulder.x + rightShoulder.x) / 2,\n        y: (leftShoulder.y + rightShoulder.y) / 2\n      };\n      \n      const hipCenter = {\n        x: (leftHip.x + rightHip.x) / 2,\n        y: (leftHip.y + rightHip.y) / 2\n      };\n      \n      const kneeCenter = {\n        x: (leftKnee.x + rightKnee.x) / 2,\n        y: (leftKnee.y + rightKnee.y) / 2\n      };\n      const ankleCenter = (vis(leftAnkle) && vis(rightAnkle)) ? {\n        x: (leftAnkle.x + rightAnkle.x) / 2,\n        y: (leftAnkle.y + rightAnkle.y) / 2\n      } : null;\n\n      // Vectors for straightness\n      const targetPoint = ankleCenter || kneeCenter;\n      const v1 = { x: shoulderCenter.x - hipCenter.x, y: shoulderCenter.y - hipCenter.y };\n      const v2 = targetPoint ? { x: targetPoint.x - hipCenter.x, y: targetPoint.y - hipCenter.y } : null;\n\n      let isGoodPosture = false;\n      if (this.exerciseMode === 'plank') {\n        // Plank: support both front-facing and side-view evaluation.\n        const cfg = window.MediaPipeConfig?.PLANK_CONFIG || {};\n\n        // Prefer side-view detection when one full side is visible (shoulder, hip, ankle)\n        const leftSideVisible = vis(leftShoulder) && vis(leftHip) && vis(leftAnkle);\n        const rightSideVisible = vis(rightShoulder) && vis(rightHip) && vis(rightAnkle);\n\n        if (leftSideVisible || rightSideVisible) {\n          const shoulder = leftSideVisible ? leftShoulder : rightShoulder;\n          const hip = leftSideVisible ? leftHip : rightHip;\n          const ankle = leftSideVisible ? leftAnkle : rightAnkle;\n\n          // Angle at hip between shoulder-hip-ankle: near 180¬∞ for a straight plank\n          const sideAngle = this.calculateAngle(shoulder, hip, ankle);\n          const minSideAngle = cfg.MIN_SIDE_ANGLE ?? 155; // degrees\n\n          isGoodPosture = sideAngle >= minSideAngle;\n\n          // optional knee check when both ankles visible\n          if (isGoodPosture && ankleCenter) {\n            const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n            const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n            const kneeMin = cfg.KNEE_MIN_DEG ?? 150;\n            const kneeOk = (leftKneeAngle >= kneeMin) && (rightKneeAngle >= kneeMin);\n            isGoodPosture = isGoodPosture && kneeOk;\n          }\n\n        } else {\n          // Fallback: use center-based straightness + orientation as before (front-facing)\n          let cosSim = -1;\n          if (v2) {\n            const mag1 = Math.hypot(v1.x, v1.y) || 1;\n            const mag2 = Math.hypot(v2.x, v2.y) || 1;\n            cosSim = (v1.x * v2.x + v1.y * v2.y) / (mag1 * mag2);\n          }\n          const absCos = Math.abs(Math.max(-1, Math.min(1, cosSim)));\n          const straightEnough = v2 ? (absCos >= (cfg.STRAIGHT_ABS_COS_MIN ?? 0.90)) : false;\n          const dx = shoulderCenter.x - hipCenter.x;\n          const dy = shoulderCenter.y - hipCenter.y;\n          const orientDeg = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);\n          const horizMax = cfg.HORIZ_MAX_DEG ?? 35;\n          const nearHorizontal = (orientDeg <= horizMax) || (orientDeg >= (180 - horizMax));\n          let kneeOk = true;\n          if (ankleCenter) {\n            const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n            const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n            const kneeMin = cfg.KNEE_MIN_DEG ?? 150;\n            kneeOk = (leftKneeAngle >= kneeMin) && (rightKneeAngle >= kneeMin);\n          }\n          isGoodPosture = straightEnough && nearHorizontal && kneeOk;\n        }\n\n      } else if (this.exerciseMode === 'squats') {\n        // Squats: accept normal descent (hip moving below knee) as a valid posture.\n        // Only flag 'BAD' when there's severe hip/back collapse (rounded back).\n        const scfg = window.MediaPipeConfig?.SQUAT_CONFIG || {};\n        const hipAngleLeft = this.calculateAngle(leftShoulder, leftHip, leftKnee);\n        const hipAngleRight = this.calculateAngle(rightShoulder, rightHip, rightKnee);\n        const hipAngle = (hipAngleLeft + hipAngleRight) / 2;\n        // Configurable thresholds\n        const hipAngleMin = scfg.HIP_ANGLE_MIN ?? 120; // generous minimum for 'upright' expectation\n        const collapseThreshold = scfg.HIP_ANGLE_COLLAPSE ?? 60; // below this -> collapsed (bad)\n        const dx = shoulderCenter.x - hipCenter.x;\n        const dy = shoulderCenter.y - hipCenter.y;\n        const torsoTiltDeg = Math.abs(Math.atan2(dx, -dy) * 180 / Math.PI);\n        const tiltMax = scfg.TORSO_TILT_MAX ?? 60;\n\n        // Determine hip vs knee vertical relationship (allow descent)\n        const hipBelowKnee = kneeCenter && (hipCenter.y > kneeCenter.y);\n\n        const collapseTiltMin = scfg.COLLAPSE_TILT_MIN ?? 70; // require significant forward rounding\n        if (hipAngle < collapseThreshold && torsoTiltDeg > collapseTiltMin) {\n          // Severe collapse (rounded back + low hip angle) ‚Äî definitely bad\n          isGoodPosture = false;\n        } else if (hipBelowKnee) {\n          // Normal squat descent ‚Äî accept as good (as long as collapse not detected)\n          isGoodPosture = true;\n        } else {\n          // Standing/upright checks: require reasonable hip angle and torso tilt\n          isGoodPosture = (hipAngle >= hipAngleMin) && (torsoTiltDeg <= tiltMax);\n        }\n      } else {\n        // Push-ups: prefer a dedicated horizontal-body check.\n        // Two modes: side view (ankles visible) -> use straight-line similarity as before.\n        // Front/angled view (no ankle visibility) -> check shoulder-hip orientation close to horizontal\n        const cfg = window.MediaPipeConfig?.PUSHUP_CONFIG || {};\n        const SIDE_ABS_COS_MIN = cfg.SIDE_ABS_COS_MIN ?? 0.82; // slightly more lenient\n        const HORIZ_TORSO_MAX_DEG = cfg.HORIZ_TORSO_MAX_DEG ?? 35; // allow more tilt\n\n        // If ankle center available assume side/diagonal view and use cos similarity\n        if (ankleCenter && v2) {\n          let cosSim = -1;\n          const mag1 = Math.hypot(v1.x, v1.y) || 1;\n          const mag2 = Math.hypot(v2.x, v2.y) || 1;\n          cosSim = (v1.x * v2.x + v1.y * v2.y) / (mag1 * mag2);\n          const absCos = Math.abs(Math.max(-1, Math.min(1, cosSim)));\n          isGoodPosture = absCos >= SIDE_ABS_COS_MIN;\n        } else {\n          // Fallback: check that shoulder-hip axis is near horizontal (small dy)\n          const dx = shoulderCenter.x - hipCenter.x;\n          const dy = shoulderCenter.y - hipCenter.y;\n          const angDeg = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);\n          // angle near 0 or near 180 -> horizontal\n          const nearHorizontal = (angDeg <= HORIZ_TORSO_MAX_DEG) || (angDeg >= (180 - HORIZ_TORSO_MAX_DEG));\n          // Also ensure it's not standing (i.e., torso nearly vertical)\n          const nearVertical = (angDeg >= 90 - 20 && angDeg <= 90 + 20);\n          isGoodPosture = nearHorizontal && !nearVertical;\n        }\n      }\n\n      console.log(`üèÉ Posture(${this.exerciseMode}): ${isGoodPosture ? 'GOOD' : 'BAD'}`);\n      \n      return isGoodPosture;\n    } catch (error) {\n      console.error('Error checking back alignment:', error);\n      return false;\n    }\n  }\n\n  // Update push-up counter\n  updatePushupCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const pushupConfig = window.MediaPipeConfig?.PUSHUP_CONFIG || {};\n      \n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const leftElbow = landmarks[config.LEFT_ELBOW || 13];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const rightElbow = landmarks[config.RIGHT_ELBOW || 14];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n\n      if (!leftShoulder || !leftElbow || !leftWrist || !rightShoulder || !rightElbow || !rightWrist || !leftHip || !rightHip) {\n        return;\n      }\n\n      // Calculate elbow angles\n      const leftElbowAngle = this.calculateAngle(leftShoulder, leftElbow, leftWrist);\n      const rightElbowAngle = this.calculateAngle(rightShoulder, rightElbow, rightWrist);\n      const avgElbowAngle = (leftElbowAngle + rightElbowAngle) / 2;\n\n      // Average shoulder position (for height detection)\n      const avgShoulderY = (leftShoulder.y + rightShoulder.y) / 2;\n\n      const downThreshold = pushupConfig.ELBOW_ANGLE_DOWN || 95;\n      const upThreshold = pushupConfig.ELBOW_ANGLE_UP || 155;\n      const shoulderHeightThreshold = pushupConfig.SHOULDER_HEIGHT_DOWN || 0.02;\n\n      // Push-up position: elbows bent OR shoulders close to ground\n      // Determine if user is likely standing: if shoulders are well above hips and torso vertical\n      const shoulderHipDy = Math.abs(((leftShoulder.y + rightShoulder.y) / 2) - ((leftHip.y + rightHip.y) / 2));\n      const torsoVerticalThreshold = pushupConfig.TORSO_VERTICAL_DY ?? 0.15; // if shoulders far above hips (normalized units)\n      const isLikelyStanding = shoulderHipDy < (pushupConfig.STANDING_DY_MIN ?? 0.05) ? false : ((leftShoulder.y + rightShoulder.y) / 2) < ((leftHip.y + rightHip.y) / 2) - (pushupConfig.STANDING_DY_MIN ?? 0.02);\n\n      // Baseline shoulder level (approx when 'up' state) ‚Äî store per-mode baseline\n      const pstate = this.perModeState['pushups'];\n      if (!pstate._baselineShoulderY) {\n        // initialize baseline to current shoulder Y when pose roughly horizontal\n        pstate._baselineShoulderY = avgShoulderY;\n      }\n\n      // If posture is not horizontal, don't update baseline; else slowly adapt baseline\n      if (Math.abs(((leftShoulder.y + rightShoulder.y) / 2) - ((leftHip.y + rightHip.y) / 2)) < 0.12) {\n        // adapt baseline slowly\n        pstate._baselineShoulderY = (pstate._baselineShoulderY * 0.95) + (avgShoulderY * 0.05);\n      }\n\n      // Push-up position: significant drop from baseline OR elbow angle threshold\n      const shoulderDrop = avgShoulderY - (pstate._baselineShoulderY || avgShoulderY);\n      const shoulderDropThreshold = pushupConfig.SHOULDER_DROP_THRESHOLD ?? 0.06; // normalized units\n      const pushupPosition = (avgElbowAngle <= downThreshold) || (shoulderDrop >= shoulderDropThreshold) || (avgShoulderY >= (1 - shoulderHeightThreshold));\n      \n      // Standing position: elbows straight and shoulders high (not horizontal)\n      const standingPosition = (avgElbowAngle >= upThreshold) && isLikelyStanding;\n\n      // In-position gating: require user to assume a stable push-up start pose before starting counting\n      if (!pstate._inPositionCount) pstate._inPositionCount = 0;\n      const inStart = this.isPushupStartPose(landmarks);\n      if (inStart) {\n        pstate._inPositionCount += 1;\n      } else {\n        pstate._inPositionCount = 0;\n      }\n\n      const REQUIRED_STABLE_FRAMES = window.MediaPipeConfig?.PUSHUP_CONFIG?.START_STABLE_FRAMES ?? 6; // ~6 frames\n      pstate._isInStartPose = pstate._inPositionCount >= REQUIRED_STABLE_FRAMES;\n\n      // Debounce reps: minimum ms between consecutive counts\n      const MIN_REP_MS = window.MediaPipeConfig?.PUSHUP_CONFIG?.MIN_REP_MS ?? 400;\n      if (!pstate._lastRepAt) pstate._lastRepAt = 0;\n      const now = Date.now();\n\n      // Only count if posture is correct and user is in start pose\n      if (this.postureStatus !== 'correct' || !pstate._isInStartPose) {\n        return; // do not count\n      }\n\n      if (pstate.state === 'up') {\n        if (pushupPosition && (now - pstate._lastRepAt) > MIN_REP_MS) {\n          pstate.state = 'down';\n          pstate.count += 1; // Count on descent\n          pstate._lastRepAt = now;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(pstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({ message: `Push-up ${pstate.count}`, type: 'success', timestamp: now });\n          }\n        }\n      } else if (pstate.state === 'down') {\n        // return to up when standingPosition or full extension detected\n        if (standingPosition || (!pushupPosition && avgElbowAngle >= upThreshold)) {\n          pstate.state = 'up'; // Reset state for next rep\n        }\n      }\n    } catch (error) {\n      console.error('Error updating push-up counter:', error);\n    }\n  }\n\n  // Update squat counter\n  updateSquatCounter(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const scfg = window.MediaPipeConfig?.SQUAT_CONFIG || {};\n\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle || !leftShoulder || !rightShoulder) return;\n\n      // Check if user is in horizontal position (like pushup) - show warning but DO NOT count if so\n      const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;\n      const hipCenterY = (leftHip.y + rightHip.y) / 2;\n      const head = landmarks[cfg.NOSE || 0];\n      const torsoDy = Math.abs(shoulderCenterY - hipCenterY);\n      const HORIZONTAL_THRESHOLD = 0.08; // Same threshold as pushup detection\n      // Check if head is at same y level as hips (head down, body horizontal)\n      const headHipDy = Math.abs((head?.y ?? 0) - hipCenterY);\n      const HEAD_HIP_HORIZONTAL_THRESHOLD = 0.10; // If head and hip are close in y, likely horizontal\n      let isHorizontalLikePushup = false;\n      if (torsoDy <= HORIZONTAL_THRESHOLD && headHipDy <= HEAD_HIP_HORIZONTAL_THRESHOLD) {\n        isHorizontalLikePushup = true;\n        // Optional: show warning\n        if (this.onFormFeedback) {\n          this.onFormFeedback({ \n            message: 'Ÿàÿ∂ÿπ ÿßŸÑÿ¨ÿ≥ŸÖ ÿ£ŸÅŸÇŸäÿå ŸÑŸÜ Ÿäÿ™ŸÖ ÿßŸÑÿπÿØ ÿ•ŸÑÿß ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ŸÉŸàÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠', \n            type: 'warning', \n            timestamp: Date.now() \n          });\n        }\n      }\n\n      // Check if hands are on the ground (like pushup)\n      const leftWrist = landmarks[cfg.LEFT_WRIST || 15];\n      const rightWrist = landmarks[cfg.RIGHT_WRIST || 16];\n      const leftFoot = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightFoot = landmarks[cfg.RIGHT_ANKLE || 28];\n      // Consider hands on ground if both wrists are at or below the level of the ankles (with small margin)\n      const HANDS_ON_GROUND_THRESHOLD = 0.07; // allow small margin\n      let handsOnGround = false;\n      if (leftWrist && rightWrist && leftFoot && rightFoot) {\n        const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n        const avgFootY = (leftFoot.y + rightFoot.y) / 2;\n        if (avgWristY >= avgFootY - HANDS_ON_GROUND_THRESHOLD) {\n          handsOnGround = true;\n          if (this.onFormFeedback) {\n            this.onFormFeedback({\n              message: 'ÿßŸÑŸäÿØŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ÿ±ÿ∂ÿå ŸÑŸÜ Ÿäÿ™ŸÖ ÿßŸÑÿπÿØ ÿ•ŸÑÿß ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ŸÉŸàÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠',\n              type: 'warning',\n              timestamp: Date.now()\n            });\n          }\n        }\n      }\n\n      // Average sides for stability\n      const hip = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      const knee = { x: (leftKnee.x + rightKnee.x) / 2, y: (leftKnee.y + rightKnee.y) / 2 };\n      const ankle = { x: (leftAnkle.x + rightAnkle.x) / 2, y: (leftAnkle.y + rightAnkle.y) / 2 };\n      const shoulder = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n\n      // Knee angle using hip-knee-ankle\n      const kneeAngleLeft = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const kneeAngleRight = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n      const avgKneeAngle = (kneeAngleLeft + kneeAngleRight) / 2;\n\n      // Check leg stability - both legs should be moving together (not one leg down)\n      const leftKneeY = leftKnee.y;\n      const rightKneeY = rightKnee.y;\n      const kneeHeightDiff = Math.abs(leftKneeY - rightKneeY);\n      const LEG_STABILITY_THRESHOLD = 0.05; // Maximum difference between left and right knee heights\n      \n      const legsStable = kneeHeightDiff <= LEG_STABILITY_THRESHOLD;\n      \n      // Check if knees are bending (squatting down)\n      const kneesBending = avgKneeAngle < 120; // Knees bent when angle is less than 120 degrees\n\n      // Count based on hip position (lower back points)\n      const hipY = hip.y; // Y position of hips (lower = deeper)\n      const kneeY = knee.y; // Y position of knees\n      \n      // Hip goes below knee level = deep squat\n      const hipBelowKnee = hipY > kneeY;\n      // Hip goes back up above knee level = standing\n      const hipAboveKnee = hipY < kneeY;\n      \n      // State machine: count when hip goes down below knee level (use per-mode state)\n      const stateObj = this.perModeState['squats'];\n\n      // Debug logging\n      console.log('üîç Squat Debug:', {\n        legsStable,\n        kneesBending,\n        avgKneeAngle,\n        kneeHeightDiff,\n        hipBelowKnee,\n        hipAboveKnee,\n        state: stateObj.state,\n        count: stateObj.count\n      });\n\n      // Simplified squat counting: count when hips go below knees with stable legs\n      const MIN_REP_MS = window.MediaPipeConfig?.SQUAT_CONFIG?.MIN_REP_MS ?? 500;\n      if (!stateObj._lastRepAt) stateObj._lastRepAt = 0;\n      const now = Date.now();\n\n      if (stateObj.state === 'up') {\n        // Count if hips go below knees and legs are stable, and NOT in horizontal position or hands on ground\n        if (hipBelowKnee && legsStable && !isHorizontalLikePushup && !handsOnGround && (now - stateObj._lastRepAt) > MIN_REP_MS) {\n          stateObj.state = 'down';\n          stateObj.count += 1;\n          stateObj._lastRepAt = now;\n          console.log('üéØ Squat counted! Count:', stateObj.count);\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(stateObj.count);\n        } else {\n          // Debug why counting didn't happen\n          if (!hipBelowKnee) {\n            console.log('‚ùå Not counting: Hips not below knees');\n          } else if (!legsStable) {\n            console.log('‚ùå Not counting: Legs not stable (one leg down)');\n          } else if (isHorizontalLikePushup) {\n            console.log('‚ùå Not counting: Body is horizontal like pushup');\n          } else if (handsOnGround) {\n            console.log('‚ùå Not counting: Hands are on the ground');\n          } else if ((now - stateObj._lastRepAt) <= MIN_REP_MS) {\n            console.log('‚ùå Not counting: Too soon since last rep');\n          }\n        }\n      } else if (stateObj.state === 'down') {\n        if (hipAboveKnee) {\n          stateObj.state = 'up';\n          console.log('‚¨ÜÔ∏è Squat state changed to UP');\n        }\n      }\n    } catch (error) {\n      console.error('Error updating squat counter:', error);\n    }\n  }\n\n  // Update lunges counter\n  updateLungesCounter(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const lcfg = window.MediaPipeConfig?.LUNGES_CONFIG || {};\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n      \n      // Check if hands are on the ground (like pushup) - don't count lunges if hands on ground\n      const leftWrist = landmarks[cfg.LEFT_WRIST || 15];\n      const rightWrist = landmarks[cfg.RIGHT_WRIST || 16];\n      const leftFoot = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightFoot = landmarks[cfg.RIGHT_ANKLE || 28];\n      const HANDS_ON_GROUND_THRESHOLD = 0.07;\n      let handsOnGround = false;\n      if (leftWrist && rightWrist && leftFoot && rightFoot) {\n        const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n        const avgFootY = (leftFoot.y + rightFoot.y) / 2;\n        if (avgWristY >= avgFootY - HANDS_ON_GROUND_THRESHOLD) {\n          handsOnGround = true;\n        }\n      }\n      \n      // Average hip position\n      const hip = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      // Calculate knee angles\n      const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n      // Determine which leg is front (more bent knee) - allow both legs to be counted\n      const leftKneeBent = leftKneeAngle < rightKneeAngle;\n      const frontKnee = leftKneeBent ? leftKnee : rightKnee;\n      const backKnee = leftKneeBent ? rightKnee : leftKnee;\n      const frontKneeAngle = leftKneeBent ? leftKneeAngle : rightKneeAngle;\n      const backKneeAngle = leftKneeBent ? rightKneeAngle : leftKneeAngle;\n      \n      // Also check the opposite leg position (for alternating lunges)\n      const rightKneeBent = rightKneeAngle < leftKneeAngle;\n      const altFrontKnee = rightKneeBent ? rightKnee : leftKnee;\n      const altBackKnee = rightKneeBent ? leftKnee : rightKnee;\n      const altFrontKneeAngle = rightKneeBent ? rightKneeAngle : leftKneeAngle;\n      const altBackKneeAngle = rightKneeBent ? leftKneeAngle : rightKneeAngle;\n      // Hip position relative to front knee\n      const hipBelowFrontKnee = hip.y > frontKnee.y;\n      // Lunge position based on the image: one leg forward, body leaning forward, back knee close to ground\n      const KNEE_Y_DIFF_THRESHOLD = 0.06; // ŸÅÿ±ŸÇ Ÿàÿßÿ∂ÿ≠ ÿ®ŸäŸÜ ÿßŸÑÿ±ŸÉÿ®ÿ™ŸäŸÜ (ÿ±ÿ¨ŸÑ ŸÑŸÑÿ£ŸÖÿßŸÖ) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const BACK_KNEE_ANGLE_THRESHOLD = 120; // back knee bent (close to ground) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const FRONT_KNEE_ANGLE_THRESHOLD = 100; // front knee bent (stable support) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const HIP_FORWARD_THRESHOLD = 0.08; // hip leaning forward over front leg - ÿ™Ÿàÿ≥Ÿäÿπ\n      \n      const kneeYDiff = Math.abs(leftKnee.y - rightKnee.y);\n      const oneLegForward = kneeYDiff > KNEE_Y_DIFF_THRESHOLD;\n      \n      // Check first leg position (left leg forward)\n      const backKneeBent = backKneeAngle < BACK_KNEE_ANGLE_THRESHOLD;\n      const frontKneeBent = frontKneeAngle < FRONT_KNEE_ANGLE_THRESHOLD;\n      const frontHip = leftKneeBent ? leftHip : rightHip;\n      const frontAnkle = leftKneeBent ? leftAnkle : rightAnkle;\n      const hipForwardLean = Math.abs(frontHip.x - frontAnkle.x) < HIP_FORWARD_THRESHOLD;\n      const lungePosition1 = oneLegForward && backKneeBent && frontKneeBent && hipForwardLean;\n      \n      // Check second leg position (right leg forward)\n      const altBackKneeBent = altBackKneeAngle < BACK_KNEE_ANGLE_THRESHOLD;\n      const altFrontKneeBent = altFrontKneeAngle < FRONT_KNEE_ANGLE_THRESHOLD;\n      const altFrontHip = rightKneeBent ? rightHip : leftHip;\n      const altFrontAnkle = rightKneeBent ? rightAnkle : leftAnkle;\n      const altHipForwardLean = Math.abs(altFrontHip.x - altFrontAnkle.x) < HIP_FORWARD_THRESHOLD;\n      const lungePosition2 = oneLegForward && altBackKneeBent && altFrontKneeBent && altHipForwardLean;\n      \n      // Either leg position counts as a lunge\n      const lungePosition = lungePosition1 || lungePosition2;\n      // Standing position: both knees straight\n      const standingPosition = (frontKneeAngle >= 160) && (backKneeAngle >= 150);\n      // Simple counting: count immediately when going down (like squats)\n      const lstate = this.perModeState['lunges'];\n      if (lstate.state === 'up') {\n        if (!handsOnGround && lungePosition) {\n          lstate.state = 'down';\n          lstate.count += 1; // Count immediately on descent\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(lstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({ message: `Lunge ${lstate.count}`, type: 'success', timestamp: Date.now() });\n          }\n        }\n      } else if (lstate.state === 'down') {\n        if (standingPosition) {\n          lstate.state = 'up'; // Reset state for next rep\n        }\n      }\n    } catch (error) {\n      console.error('Error updating lunges counter:', error);\n    }\n  }\n\n  // Add Burpees counter\n  // Update mountain climbers counter\n  updateMountainClimbersCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      \n      // Get key body points\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n\n      // Calculate vertical distances between knees and hips\n      const leftKneeToHipY = Math.abs(leftKnee.y - leftHip.y);\n      const rightKneeToHipY = Math.abs(rightKnee.y - rightHip.y);\n\n      // Initialize states if needed\n      if (!this._lastLeftKneeY) this._lastLeftKneeY = leftKnee.y;\n      if (!this._lastRightKneeY) this._lastRightKneeY = rightKnee.y;\n      if (!this._climberState) this._climberState = 'neutral';\n      if (!this._lastClimberTime) this._lastClimberTime = Date.now();\n      \n      const KNEE_THRESHOLD = 0.05; // How far the knee needs to move\n      const MIN_REP_TIME = 250; // Minimum time between reps (ms)\n      const currentTime = Date.now();\n\n      // Calculate knee movements\n      const leftKneeMove = leftKnee.y - this._lastLeftKneeY;\n      const rightKneeMove = rightKnee.y - this._lastRightKneeY;\n\n      // Check for significant knee movements in opposite directions\n      const isAlternating = (leftKneeMove > KNEE_THRESHOLD && rightKneeMove < -KNEE_THRESHOLD) ||\n                           (leftKneeMove < -KNEE_THRESHOLD && rightKneeMove > KNEE_THRESHOLD);\n\n      // State machine for counting alternating leg movements\n      const cmode = this.perModeState['mountainclimbers'];\n      if (cmode._climberState === 'neutral') {\n        if (isAlternating && (currentTime - cmode._lastClimberTime > MIN_REP_TIME)) {\n          cmode._climberState = 'moving';\n          cmode._lastClimberTime = currentTime;\n          // Count the rep\n          cmode.count += 1;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(cmode.count);\n          if (this.onFormFeedback) {\n            const leg = leftKneeMove > rightKneeMove ? 'Left' : 'Right';\n            this.onFormFeedback({\n              message: `${leg} knee drive - Rep ${cmode.count}`,\n              type: 'success',\n              timestamp: currentTime\n            });\n          }\n        }\n      } else if (cmode._climberState === 'moving') {\n        if (!isAlternating) {\n          cmode._climberState = 'neutral';\n        }\n      }\n\n      // Update last positions\n      cmode._lastLeftKneeY = leftKnee.y;\n      cmode._lastRightKneeY = rightKnee.y;\n\n      // Form feedback for incorrect movement\n      if (Math.abs(leftHip.y - rightHip.y) > 0.1) { // Hips not level\n        if (this.onFormFeedback && Math.random() < 0.1) {\n          this.onFormFeedback({\n            message: \"Keep hips level!\",\n            type: \"warning\",\n            timestamp: currentTime\n          });\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating mountain climbers counter:', error);\n    }\n  }\n\n  updateBurpeesCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      // ŸÜŸÇÿßÿ∑ ÿßŸÑÿ±ÿ£ÿ≥ ŸàÿßŸÑŸäÿØŸäŸÜ\n      const nose = landmarks[config.NOSE || 0];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftIndex = landmarks[config.LEFT_INDEX || 19];\n      const rightIndex = landmarks[config.RIGHT_INDEX || 20];\n      if (!nose || !leftWrist || !rightWrist) return;\n      // ÿ£ÿπŸÑŸâ ŸÜŸÇÿ∑ÿ© ŸÑŸÑÿ±ÿ£ÿ≥\n      const headY = nose.y;\n      // ÿ£ÿπŸÑŸâ ŸÜŸÇÿ∑ÿ© ŸÑŸÑŸäÿØ ÿ£Ÿà ÿßŸÑÿ£ÿµÿßÿ®ÿπ\n      const leftHandY = leftIndex ? leftIndex.y : leftWrist.y;\n      const rightHandY = rightIndex ? rightIndex.y : rightWrist.y;\n      // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸäÿØŸäŸÜ ÿ£Ÿà ÿßŸÑÿ£ÿµÿßÿ®ÿπ ÿ£ÿπŸÑŸâ ŸÖŸÜ ÿßŸÑÿ±ÿ£ÿ≥ (ÿ£ŸÇŸÑ ŸÅŸä ŸÇŸäŸÖÿ© y)\n      const handsAboveHead = (leftHandY < headY && rightHandY < headY);\n      // ŸÖŸÜÿ∑ŸÇ ÿßŸÑÿπÿØ\n      if (!this._burpeeState) this._burpeeState = 'ready';\n      if (!this.perModeState['burpees']._burpeeState) this.perModeState['burpees']._burpeeState = 'ready';\n      const bstate = this.perModeState['burpees'];\n      if (bstate._burpeeState === 'ready') {\n        if (handsAboveHead) {\n          bstate._burpeeState = 'jumping';\n          bstate.count += 1;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(bstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({\n              message: `Burpee ${bstate.count} - Hands above head!`,\n              type: 'success',\n              timestamp: Date.now()\n            });\n          }\n        }\n      } else if (bstate._burpeeState === 'jumping') {\n        if (!handsAboveHead) {\n          bstate._burpeeState = 'ready';\n        }\n      }\n    } catch (error) {\n      console.error('Error updating burpees counter:', error);\n    }\n  }\n\n  updateHighKneesCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n\n      // Check if knee is at waist level or above (easier threshold)\n      const KNEE_HIP_THRESHOLD = 0.03; // Knee should be at waist level or above (easier)\n      const isLeftKneeHigh = (leftHip.y - leftKnee.y) > KNEE_HIP_THRESHOLD;\n      const isRightKneeHigh = (rightHip.y - rightKnee.y) > KNEE_HIP_THRESHOLD;\n\n      // Check if user is doing high knees movement (either leg up)\n      const isDoingHighKnees = isLeftKneeHigh || isRightKneeHigh;\n\n      // State machine for timing high knees (per-mode)\n      const hk = this.perModeState['highknees'];\n      if (!hk._highKneesState) hk._highKneesState = 'stopped';\n      if (!hk._startTime) hk._startTime = 0;\n      if (!hk._lastUpdateTime) hk._lastUpdateTime = 0;\n\n      const now = Date.now();\n      const MIN_MOVEMENT_INTERVAL = 100; // Minimum time between movements (ms)\n\n      if (hk._highKneesState === 'stopped') {\n        // Start timing when user begins high knees movement\n        if (isDoingHighKnees) {\n          hk._highKneesState = 'active';\n          hk._startTime = now;\n          hk._lastUpdateTime = now;\n          hk.count = 0; // Reset count\n          console.log('üèÉ High Knees started!');\n        }\n      } else if (hk._highKneesState === 'active') {\n        if (isDoingHighKnees) {\n          // Continue timing while user is doing high knees\n          hk._lastUpdateTime = now;\n          const elapsedSeconds = Math.floor((now - hk._startTime) / 1000);\n          \n          // Update count (in seconds) every second\n          if (elapsedSeconds > hk.count) {\n            hk.count = elapsedSeconds;\n            if (this.onPushupCount) this.onPushupCount(hk.count);\n            console.log(`‚è±Ô∏è High Knees: ${elapsedSeconds} seconds`);\n          }\n        } else {\n          // Check if user stopped for too long\n          const timeSinceLastMovement = now - hk._lastUpdateTime;\n          if (timeSinceLastMovement > 1500) { // Stop if no movement for 1.5 seconds\n            hk._highKneesState = 'stopped';\n            console.log('‚èπÔ∏è High Knees stopped!');\n          }\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating high knees counter:', error);\n    }\n  }\n\n  // Update jumping jacks counter\n  updateJumpingJacksCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const jjConfig = window.MediaPipeConfig?.JUMPINGJACKS_CONFIG || {};\n\n      // Get key landmarks for jumping jacks\n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftElbow = landmarks[config.LEFT_ELBOW || 13];\n      const rightElbow = landmarks[config.RIGHT_ELBOW || 14];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      if (!leftShoulder || !rightShoulder || !leftHip || !rightHip || !leftKnee || !rightKnee || !leftElbow || !rightElbow || !leftWrist || !rightWrist || !leftAnkle || !rightAnkle) {\n        return;\n      }\n\n      // Calculate shoulder abduction angles (shoulder-elbow-wrist) - arms overhead\n      const leftShoulderAbduction = this.calculateAngle(leftElbow, leftShoulder, leftWrist);\n      const rightShoulderAbduction = this.calculateAngle(rightElbow, rightShoulder, rightWrist);\n\n      // Calculate hip abduction angles (hip-knee-ankle) - legs apart\n      const leftHipAbduction = this.calculateAngle(leftKnee, leftHip, leftAnkle);\n      const rightHipAbduction = this.calculateAngle(rightKnee, rightHip, rightAnkle);\n\n      // Calculate knee flexion angles (hip-knee-ankle)\n      const leftKneeFlexion = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const rightKneeFlexion = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n\n      // Simplified thresholds - make them more lenient for better detection\n      const SHOULDER_ABDUCTION_DOWN = jjConfig.SHOULDER_ABDUCTION_DOWN || 60;    // More lenient for arms down\n      const SHOULDER_ABDUCTION_UP = jjConfig.SHOULDER_ABDUCTION_UP || 120;      // More lenient for arms overhead\n      const HIP_ABDUCTION_DOWN = jjConfig.HIP_ABDUCTION_DOWN || 25;             // More lenient for legs together\n      const HIP_ABDUCTION_UP = jjConfig.HIP_ABDUCTION_UP || 30;                 // More lenient for legs apart\n\n      // Simplified state detection - focus on the main movements\n      const avgShoulderAbduction = (leftShoulderAbduction + rightShoulderAbduction) / 2;\n      const avgHipAbduction = (leftHipAbduction + rightHipAbduction) / 2;\n\n      // Alternative: Use position-based detection (more reliable)\n      const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n      const avgShoulderY = (leftShoulder.y + rightShoulder.y) / 2;\n      const avgAnkleY = (leftAnkle.y + rightAnkle.y) / 2;\n      const avgHipY = (leftHip.y + rightHip.y) / 2;\n      \n      // Arms overhead: wrists above shoulders\n      const armsOverhead = avgWristY < avgShoulderY;\n      // Legs apart: ankles spread wider than hips\n      const legsApart = Math.abs(leftAnkle.x - rightAnkle.x) > Math.abs(leftHip.x - rightHip.x) * 1.2;\n\n      // UP state: arms overhead AND legs apart (using position OR angles)\n      const isUpState = (armsOverhead && legsApart) || (avgShoulderAbduction > SHOULDER_ABDUCTION_UP && avgHipAbduction > HIP_ABDUCTION_UP);\n\n      // DOWN state: arms down AND legs together (using position OR angles)\n      const isDownState = (!armsOverhead && !legsApart) || (avgShoulderAbduction < SHOULDER_ABDUCTION_DOWN && avgHipAbduction < HIP_ABDUCTION_DOWN);\n\n      // State machine for counting jumping jacks\n      const jjState = this.perModeState['jumpingjacks'];\n      \n      // Debounce reps: minimum ms between consecutive counts\n      const MIN_REP_MS = jjConfig.MIN_REP_MS || 800;\n      if (!jjState._lastRepAt) jjState._lastRepAt = 0;\n      const now = Date.now();\n\n      // Debug logging\n      console.log('üîç Jumping Jacks Debug:', {\n        // Angle-based detection\n        avgShoulderAbduction: Math.round(avgShoulderAbduction),\n        avgHipAbduction: Math.round(avgHipAbduction),\n        shoulderThresholdUp: SHOULDER_ABDUCTION_UP,\n        shoulderThresholdDown: SHOULDER_ABDUCTION_DOWN,\n        hipThresholdUp: HIP_ABDUCTION_UP,\n        hipThresholdDown: HIP_ABDUCTION_DOWN,\n        // Position-based detection\n        avgWristY: Math.round(avgWristY * 1000) / 1000,\n        avgShoulderY: Math.round(avgShoulderY * 1000) / 1000,\n        armsOverhead,\n        legsApart,\n        ankleDistance: Math.round(Math.abs(leftAnkle.x - rightAnkle.x) * 1000) / 1000,\n        hipDistance: Math.round(Math.abs(leftHip.x - rightHip.x) * 1000) / 1000,\n        // Final states\n        isUpState,\n        isDownState,\n        state: jjState.state,\n        count: jjState.count\n      });\n\n      // State machine: DOWN -> UP -> DOWN (count) -> repeat\n      if (jjState.state === 'down') {\n        // Transition to UP state when both arms and legs are in UP position (Peak Position)\n        // Add debouncing to prevent rapid state changes\n        if (isUpState && (now - (jjState._lastStateChange || 0)) > 300) {\n          jjState.state = 'up';\n          jjState._lastStateChange = now;\n          console.log('‚¨ÜÔ∏è Jumping Jack state changed to UP (Peak Position)');\n        }\n      } else if (jjState.state === 'up') {\n        // Complete the rep and count when transitioning back to DOWN state (Return to Starting Position)\n        // Ensure we've been in UP state for a minimum time and debounce the count\n        if (isDownState && (now - jjState._lastRepAt) > MIN_REP_MS && (now - (jjState._lastStateChange || 0)) > 300) {\n          jjState.state = 'down';\n          jjState.count += 1;\n          jjState._lastRepAt = now;\n          jjState._lastStateChange = now;\n          console.log('üéØ Jumping Jack counted! Count:', jjState.count);\n          this.playSuccessSound();\n          if (this.onPushupCount) this.onPushupCount(jjState.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({\n              message: `Jumping Jack ${jjState.count}`,\n              type: 'success',\n              timestamp: now\n            });\n          }\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating jumping jacks counter:', error);\n    }\n  }\n\n  // Update side plank counter (time-based like regular plank)\n  updateSidePlankCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const spConfig = window.MediaPipeConfig?.SIDEPLANK_CONFIG || {};\n\n      // Get key landmarks for side plank\n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const leftElbow = landmarks[config.LEFT_ELBOW || 13];\n      const rightElbow = landmarks[config.RIGHT_ELBOW || 14];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n      const nose = landmarks[config.NOSE || 0];\n      const leftEar = landmarks[config.LEFT_EAR || 7];\n      const rightEar = landmarks[config.RIGHT_EAR || 8];\n\n      // Check visibility of key landmarks\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      \n      // Determine which side is the support side (left or right)\n      // We'll check both sides and use the one with better visibility\n      const leftSideVisible = vis(leftShoulder) && vis(leftElbow) && vis(leftHip) && vis(leftKnee) && vis(leftAnkle);\n      const rightSideVisible = vis(rightShoulder) && vis(rightElbow) && vis(rightHip) && vis(rightKnee) && vis(rightAnkle);\n      \n      if (!leftSideVisible && !rightSideVisible) {\n        return; // Not enough landmarks visible\n      }\n\n      // Use the side with better visibility\n      const isLeftSide = leftSideVisible && (!rightSideVisible || leftSideVisible);\n      const supportShoulder = isLeftSide ? leftShoulder : rightShoulder;\n      const supportElbow = isLeftSide ? leftElbow : rightElbow;\n      const supportWrist = isLeftSide ? leftWrist : rightWrist;\n      const supportHip = isLeftSide ? leftHip : rightHip;\n      const supportKnee = isLeftSide ? leftKnee : rightKnee;\n      const supportAnkle = isLeftSide ? leftAnkle : rightAnkle;\n      const supportEar = isLeftSide ? leftEar : rightEar;\n\n      // Calculate key angles for side plank validation\n      \n      // 1. Shoulder Support Angle (shoulder-elbow-wrist) - should be ~90¬∞\n      const shoulderSupportAngle = this.calculateAngle(supportShoulder, supportElbow, supportWrist);\n      const SHOULDER_ANGLE_MIN = spConfig.SHOULDER_ANGLE_MIN || 80;\n      const SHOULDER_ANGLE_MAX = spConfig.SHOULDER_ANGLE_MAX || 100;\n      const shoulderAngleGood = shoulderSupportAngle >= SHOULDER_ANGLE_MIN && shoulderSupportAngle <= SHOULDER_ANGLE_MAX;\n\n      // 2. Torso-Hip Line (shoulder-hip-ankle) - should be ~180¬∞ (straight line)\n      const torsoHipAngle = this.calculateAngle(supportShoulder, supportHip, supportAnkle);\n      const TORSO_ANGLE_MIN = spConfig.TORSO_ANGLE_MIN || 160;\n      const TORSO_ANGLE_MAX = spConfig.TORSO_ANGLE_MAX || 200;\n      const torsoAngleGood = torsoHipAngle >= TORSO_ANGLE_MIN && torsoHipAngle <= TORSO_ANGLE_MAX;\n\n      // 3. Check for hip sag (hip drops below shoulder-ankle line)\n      const shoulderAnkleMidY = (supportShoulder.y + supportAnkle.y) / 2;\n      const hipSagThreshold = spConfig.HIP_SAG_THRESHOLD || 0.05; // normalized units\n      const hipSag = supportHip.y > (shoulderAnkleMidY + hipSagThreshold);\n      \n      // 4. Check for hip hike (hip rises above shoulder-ankle line)\n      const hipHikeThreshold = spConfig.HIP_HIKE_THRESHOLD || 0.05; // normalized units\n      const hipHike = supportHip.y < (shoulderAnkleMidY - hipHikeThreshold);\n\n      // 5. Check elbow alignment (elbow should be under shoulder)\n      const elbowAlignmentThreshold = spConfig.ELBOW_ALIGNMENT_THRESHOLD || 0.08; // normalized units\n      const elbowAligned = Math.abs(supportElbow.x - supportShoulder.x) < elbowAlignmentThreshold;\n\n      // 6. Check feet stacking (ankles should be close together)\n      const feetStackingThreshold = spConfig.FEET_STACKING_THRESHOLD || 0.1; // normalized units\n      const feetStacked = Math.abs(leftAnkle.x - rightAnkle.x) < feetStackingThreshold;\n\n      // 7. Head-neck alignment (ear-shoulder-hip should be ~180¬∞)\n      let headNeckGood = true;\n      if (supportEar && vis(supportEar)) {\n        const headNeckAngle = this.calculateAngle(supportEar, supportShoulder, supportHip);\n        const HEAD_NECK_ANGLE_MIN = spConfig.HEAD_NECK_ANGLE_MIN || 160;\n        const HEAD_NECK_ANGLE_MAX = spConfig.HEAD_NECK_ANGLE_MAX || 200;\n        headNeckGood = headNeckAngle >= HEAD_NECK_ANGLE_MIN && headNeckAngle <= HEAD_NECK_ANGLE_MAX;\n      }\n\n      // Overall posture assessment\n      const isGoodPosture = shoulderAngleGood && \n                           torsoAngleGood && \n                           !hipSag && \n                           !hipHike && \n                           elbowAligned && \n                           feetStacked && \n                           headNeckGood;\n\n      // Debug logging\n      console.log('üîç Side Plank Debug:', {\n        side: isLeftSide ? 'Left' : 'Right',\n        shoulderAngle: Math.round(shoulderSupportAngle),\n        torsoAngle: Math.round(torsoHipAngle),\n        hipSag,\n        hipHike,\n        elbowAligned,\n        feetStacked,\n        headNeckGood,\n        isGoodPosture,\n        postureStatus: this.postureStatus\n      });\n\n      // Update posture status with smoothing\n      if (isGoodPosture) {\n        this._postureGoodCount = (this._postureGoodCount || 0) + 1;\n        this._postureBadCount = 0;\n      } else {\n        this._postureBadCount = (this._postureBadCount || 0) + 1;\n        this._postureGoodCount = 0;\n      }\n\n      const POSTURE_GOOD_FRAMES = spConfig.POSTURE_GOOD_FRAMES || 3;\n      const POSTURE_BAD_FRAMES = spConfig.POSTURE_BAD_FRAMES || 4;\n\n      let smoothedStatus = this.postureStatus;\n      if (this._postureGoodCount >= POSTURE_GOOD_FRAMES) {\n        smoothedStatus = 'correct';\n      } else if (this._postureBadCount >= POSTURE_BAD_FRAMES) {\n        smoothedStatus = 'incorrect';\n      }\n\n      if (smoothedStatus !== this.postureStatus) {\n        this.postureStatus = smoothedStatus;\n        if (this.onPostureChange) this.onPostureChange(this.postureStatus, landmarks);\n      }\n\n      // Handle timing for side plank (similar to regular plank)\n      if (this.postureStatus === 'correct') {\n        const now = Date.now();\n        if (!this.timerRunning) {\n          this.startCorrectTimestampMs = now;\n          this.timerRunning = true;\n        }\n        const totalMs = this.accumulatedCorrectMs + (now - (this.startCorrectTimestampMs || now));\n        const seconds = Math.floor(totalMs / 1000);\n        if (this.onTimeUpdate) this.onTimeUpdate(seconds);\n      } else {\n        // Stop timer when posture is incorrect\n        if (this.timerRunning) {\n          this.accumulatedCorrectMs += Date.now() - this.startCorrectTimestampMs;\n          this.timerRunning = false;\n          this.startCorrectTimestampMs = 0;\n          if (this.onTimeUpdate) {\n            this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n          }\n        }\n      }\n\n      // Provide form feedback for common mistakes\n      if (!isGoodPosture && this.onFormFeedback) {\n        const currentTime = Date.now();\n        const cooldown = spConfig.WARNING_COOLDOWN || 2000;\n        \n        if (currentTime - this.lastWarningTime > cooldown) {\n          let feedbackMessage = '';\n          if (hipSag) {\n            feedbackMessage = 'Hip sagging - lift your hips up!';\n          } else if (hipHike) {\n            feedbackMessage = 'Hip too high - lower your hips!';\n          } else if (!elbowAligned) {\n            feedbackMessage = 'Keep elbow under shoulder!';\n          } else if (!feetStacked) {\n            feedbackMessage = 'Stack your feet together!';\n          } else if (!shoulderAngleGood) {\n            feedbackMessage = 'Adjust your arm position!';\n          } else if (!torsoAngleGood) {\n            feedbackMessage = 'Keep your body straight!';\n          }\n\n          if (feedbackMessage) {\n            this.onFormFeedback({\n              message: feedbackMessage,\n              type: 'warning',\n              timestamp: currentTime\n            });\n            this.lastWarningTime = currentTime;\n          }\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating side plank counter:', error);\n    }\n  }\n\n  // Play warning sound\n  playWarningSound() {\n    try {\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n      \n      oscillator.connect(gainNode);\n      gainNode.connect(audioContext.destination);\n      \n      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);\n      oscillator.type = 'sine';\n      \n      gainNode.gain.setValueAtTime(0, audioContext.currentTime);\n      gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);\n      \n      oscillator.start(audioContext.currentTime);\n      oscillator.stop(audioContext.currentTime + 0.5);\n    } catch (error) {\n      console.error('Error playing warning sound:', error);\n    }\n  }\n\n  // Play success sound (pop.wav)\n  playSuccessSound() {\n    try {\n      const audio = new Audio('/assets/sounds/pop.wav');\n      audio.volume = 0.5; // Set volume to 50%\n      audio.play().catch(error => {\n        console.error('Error playing success sound:', error);\n      });\n    } catch (error) {\n      console.error('Error creating success sound:', error);\n    }\n  }\n\n  // Draw pose landmarks on canvas\n  drawPoseOverlay(canvasCtx, results, canvasWidth, canvasHeight) {\n    // Only log occasionally to avoid spam\n    if (Math.random() < 0.05) {\n      console.log('üé® Drawing pose overlay with', results.poseLandmarks?.length || 0, 'landmarks');\n    }\n\n    if (!results.poseLandmarks || !canvasCtx) {\n      return;\n    }\n\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n    // Draw landmarks\n    const landmarks = results.poseLandmarks;\n    let drawnLandmarks = 0;\n    \n    landmarks.forEach((landmark, index) => {\n      if (landmark.visibility && landmark.visibility > 0.5) {\n        const x = landmark.x * canvasWidth;\n        const y = landmark.y * canvasHeight;\n        \n        canvasCtx.beginPath();\n        canvasCtx.arc(x, y, 6, 0, 2 * Math.PI); // Bigger circles\n        canvasCtx.fillStyle = landmark.visibility > 0.7 ? '#10B981' : '#F59E0B';\n        canvasCtx.fill();\n        canvasCtx.strokeStyle = '#FFFFFF';\n        canvasCtx.lineWidth = 2;\n        canvasCtx.stroke();\n        drawnLandmarks++;\n      }\n    });\n\n    // Only log occasionally\n    if (Math.random() < 0.1) {\n      console.log('‚ú® Drew', drawnLandmarks, 'landmarks');\n    }\n\n    // Always use basic connections (more reliable)\n    this.drawBasicConnections(canvasCtx, landmarks, canvasWidth, canvasHeight);\n\n    canvasCtx.restore();\n  }\n\n  // Draw basic pose connections\n  drawBasicConnections(canvasCtx, landmarks, canvasWidth, canvasHeight) {\n    const connections = [\n      [11, 12], // shoulders\n      [11, 13], // left shoulder to elbow\n      [13, 15], // left elbow to wrist\n      [12, 14], // right shoulder to elbow\n      [14, 16], // right elbow to wrist\n      [11, 23], // left shoulder to hip\n      [12, 24], // right shoulder to hip\n      [23, 24], // hips\n      [23, 25], // left hip to knee\n      [25, 27], // left knee to ankle\n      [24, 26], // right hip to knee\n      [26, 28]  // right knee to ankle\n    ];\n\n    let drawnConnections = 0;\n    connections.forEach(([startIdx, endIdx]) => {\n      const startPoint = landmarks[startIdx];\n      const endPoint = landmarks[endIdx];\n\n      if (startPoint && endPoint && \n          startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n        canvasCtx.beginPath();\n        canvasCtx.moveTo(startPoint.x * canvasWidth, startPoint.y * canvasHeight);\n        canvasCtx.lineTo(endPoint.x * canvasWidth, endPoint.y * canvasHeight);\n        canvasCtx.strokeStyle = '#3B82F6';\n        canvasCtx.lineWidth = 3; // Thicker lines\n        canvasCtx.stroke();\n        drawnConnections++;\n      }\n    });\n    \n    // Only log occasionally\n    if (Math.random() < 0.02) {\n      console.log('‚úÖ Drawing completed!', drawnConnections, 'connections');\n    }\n  }\n\n  // Reset counter\n  resetCounter() {\n    // Reset only the counters/state for the currently selected exercise\n    const mode = this.exerciseMode;\n    if (this.perModeState && this.perModeState[mode]) {\n      this.perModeState[mode].count = 0;\n      this.perModeState[mode].state = 'up';\n      // reset mode-specific extras\n      if (mode === 'mountainclimbers') {\n        this.perModeState[mode]._lastLeftKneeY = null;\n        this.perModeState[mode]._lastRightKneeY = null;\n        this.perModeState[mode]._climberState = 'neutral';\n        this.perModeState[mode]._lastClimberTime = 0;\n      }\n      if (mode === 'burpees') {\n        this.perModeState[mode]._burpeeState = 'ready';\n      }\n      if (mode === 'jumpingjacks') {\n        this.perModeState[mode]._lastRepAt = 0;\n      }\n      if (mode === 'sideplank') {\n        // Reset side plank state\n        this.perModeState[mode].state = 'neutral';\n        this.perModeState[mode].count = 0;\n      }\n    }\n    this.postureStatus = 'unknown';\n    // Reset plank timing\n    this.accumulatedCorrectMs = 0;\n    this.timerRunning = false;\n    this.startCorrectTimestampMs = 0;\n  }\n\n  // Get current stats\n  getStats() {\n    const mode = this.exerciseMode;\n    const stateObj = this.perModeState && this.perModeState[mode] ? this.perModeState[mode] : { count: 0, state: 'up' };\n    return {\n      count: stateObj.count || 0,\n      state: stateObj.state || 'up',\n      posture: this.postureStatus,\n      timeSec: Math.floor((this.accumulatedCorrectMs + (this.timerRunning ? (Date.now() - this.startCorrectTimestampMs) : 0)) / 1000)\n    };\n  }\n\n  // Get latest pose results for drawing\n  getLastResults() {\n    return this.lastResults;\n  }\n\n  // Set callback functions\n  setCallbacks({ onPushupCount, onPostureChange, onFormFeedback, onTimeUpdate }) {\n    this.onPushupCount = onPushupCount;\n    this.onPostureChange = onPostureChange;\n    this.onFormFeedback = onFormFeedback;\n    this.onTimeUpdate = onTimeUpdate;\n  }\n\n  // Cleanup\n  cleanup() {\n    if (this.pose) {\n      this.pose.close();\n      this.pose = null;\n    }\n    this.isInitialized = false;\n  }\n}\n\nexport default PoseDetectionUtils;\n"],"names":["PoseDetectionUtils","constructor","this","pose","isInitialized","perModeState","state","count","_lastLeftKneeY","_lastRightKneeY","_climberState","_lastClimberTime","postureStatus","lastWarningTime","videoDimensionsLogged","exerciseMode","accumulatedCorrectMs","timerRunning","startCorrectTimestampMs","onPushupCount","onPostureChange","onFormFeedback","onTimeUpdate","setExerciseMode","mode","normalized","String","toLowerCase","includes","initialize","_a","window","Pose","attempts","Promise","resolve","setTimeout","locateFile","file","config","MediaPipeConfig","POSE_CONFIG","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","setOptions","onResults","bind","error","processFrame","videoElement","Math","random","videoWidth","videoHeight","maxWidth","maxHeight","send","image","message","results","_b","_c","_d","_e","_f","_g","_h","_i","lastResults","poseLandmarks","Date","now","floor","landmarks","isPostureCorrectInstant","checkBackAlignment","_postureGoodCount","_postureBadCount","POSTURE_GOOD_FRAMES","SQUAT_CONFIG","POSTURE_BAD_FRAMES","smoothedStatus","cfg","POSE_LANDMARKS","leftHip","LEFT_HIP","rightHip","RIGHT_HIP","leftKnee","LEFT_KNEE","rightKnee","RIGHT_KNEE","hipCenter","x","y","kneeCenter","currentTime","cooldown","PLANK_CONFIG","WARNING_COOLDOWN","playWarningSound","type","timestamp","totalMs","seconds","updateSquatCounter","updateLungesCounter","updateBurpeesCounter","updateMountainClimbersCounter","updateHighKneesCounter","updateJumpingJacksCounter","updateSidePlankCounter","updatePushupCounter","calculateAngle","point1","point2","point3","radians","atan2","angle","abs","PI","isPushupStartPose","leftShoulder","LEFT_SHOULDER","rightShoulder","RIGHT_SHOULDER","leftAnkle","LEFT_ANKLE","rightAnkle","RIGHT_ANKLE","vis","p","visibility","shoulderCenterY","hipCenterY","torsoDy","PUSHUP_CONFIG","START_TORSO_DY","e","isSquatStartPose","hipY","kneeY","START_HIP_KNEE_GAP","shoulderCenter","dx","dy","angDeg","MIN_VERT","STANDING_TORSO_MIN_DEG","MAX_VERT","STANDING_TORSO_MAX_DEG","leftSideOk","rightSideOk","ankleCenter","targetPoint","v1","v2","isGoodPosture","leftSideVisible","rightSideVisible","shoulder","hip","ankle","sideAngle","MIN_SIDE_ANGLE","leftKneeAngle","rightKneeAngle","kneeMin","KNEE_MIN_DEG","cosSim","mag1","hypot","mag2","absCos","max","min","straightEnough","STRAIGHT_ABS_COS_MIN","orientDeg","horizMax","HORIZ_MAX_DEG","nearHorizontal","kneeOk","scfg","hipAngleLeft","hipAngle","hipAngleMin","HIP_ANGLE_MIN","collapseThreshold","HIP_ANGLE_COLLAPSE","torsoTiltDeg","tiltMax","TORSO_TILT_MAX","hipBelowKnee","collapseTiltMin","COLLAPSE_TILT_MIN","SIDE_ABS_COS_MIN","HORIZ_TORSO_MAX_DEG","pushupConfig","leftElbow","LEFT_ELBOW","leftWrist","LEFT_WRIST","rightElbow","RIGHT_ELBOW","rightWrist","RIGHT_WRIST","leftElbowAngle","avgElbowAngle","avgShoulderY","downThreshold","ELBOW_ANGLE_DOWN","upThreshold","ELBOW_ANGLE_UP","shoulderHeightThreshold","SHOULDER_HEIGHT_DOWN","shoulderHipDy","isLikelyStanding","TORSO_VERTICAL_DY","STANDING_DY_MIN","pstate","_baselineShoulderY","shoulderDrop","shoulderDropThreshold","SHOULDER_DROP_THRESHOLD","pushupPosition","standingPosition","_inPositionCount","REQUIRED_STABLE_FRAMES","START_STABLE_FRAMES","_isInStartPose","MIN_REP_MS","_lastRepAt","playSuccessSound","head","NOSE","HORIZONTAL_THRESHOLD","headHipDy","isHorizontalLikePushup","leftFoot","rightFoot","HANDS_ON_GROUND_THRESHOLD","handsOnGround","avgWristY","knee","kneeAngleLeft","leftKneeY","rightKneeY","kneeHeightDiff","legsStable","hipAboveKnee","stateObj","LUNGES_CONFIG","leftKneeBent","frontKnee","frontKneeAngle","backKneeAngle","rightKneeBent","altFrontKneeAngle","altBackKneeAngle","KNEE_Y_DIFF_THRESHOLD","BACK_KNEE_ANGLE_THRESHOLD","FRONT_KNEE_ANGLE_THRESHOLD","HIP_FORWARD_THRESHOLD","oneLegForward","backKneeBent","frontKneeBent","frontHip","frontAnkle","hipForwardLean","lungePosition1","altBackKneeBent","altFrontKneeBent","altFrontHip","altFrontAnkle","altHipForwardLean","lungePosition","lstate","KNEE_THRESHOLD","MIN_REP_TIME","leftKneeMove","rightKneeMove","isAlternating","cmode","leg","nose","leftIndex","LEFT_INDEX","rightIndex","RIGHT_INDEX","headY","leftHandY","rightHandY","handsAboveHead","_burpeeState","bstate","KNEE_HIP_THRESHOLD","isLeftKneeHigh","isRightKneeHigh","isDoingHighKnees","hk","_highKneesState","_startTime","_lastUpdateTime","elapsedSeconds","jjConfig","JUMPINGJACKS_CONFIG","leftShoulderAbduction","rightShoulderAbduction","leftHipAbduction","rightHipAbduction","SHOULDER_ABDUCTION_DOWN","SHOULDER_ABDUCTION_UP","HIP_ABDUCTION_DOWN","HIP_ABDUCTION_UP","avgShoulderAbduction","avgHipAbduction","armsOverhead","legsApart","isUpState","isDownState","jjState","_lastStateChange","spConfig","SIDEPLANK_CONFIG","leftEar","LEFT_EAR","rightEar","RIGHT_EAR","isLeftSide","supportShoulder","supportElbow","supportWrist","supportHip","supportAnkle","supportEar","shoulderSupportAngle","SHOULDER_ANGLE_MIN","SHOULDER_ANGLE_MAX","shoulderAngleGood","torsoHipAngle","TORSO_ANGLE_MIN","TORSO_ANGLE_MAX","torsoAngleGood","shoulderAnkleMidY","hipSagThreshold","HIP_SAG_THRESHOLD","hipSag","hipHikeThreshold","HIP_HIKE_THRESHOLD","hipHike","elbowAlignmentThreshold","ELBOW_ALIGNMENT_THRESHOLD","elbowAligned","feetStackingThreshold","FEET_STACKING_THRESHOLD","feetStacked","headNeckGood","headNeckAngle","HEAD_NECK_ANGLE_MIN","HEAD_NECK_ANGLE_MAX","feedbackMessage","audioContext","AudioContext","webkitAudioContext","oscillator","createOscillator","gainNode","createGain","connect","destination","frequency","setValueAtTime","gain","linearRampToValueAtTime","exponentialRampToValueAtTime","start","stop","audio","Audio","volume","play","catch","drawPoseOverlay","canvasCtx","canvasWidth","canvasHeight","save","clearRect","forEach","landmark","index","beginPath","arc","fillStyle","fill","strokeStyle","lineWidth","stroke","drawBasicConnections","restore","startIdx","endIdx","startPoint","endPoint","moveTo","lineTo","resetCounter","getStats","posture","timeSec","getLastResults","setCallbacks","cleanup","close"],"mappings":"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"}