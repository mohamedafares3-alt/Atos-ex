{"version":3,"file":"poseDetection-DoTgMxbD.js","sources":["../../src/utils/poseDetection.js"],"sourcesContent":["// Pose detection utilities using MediaPipe\nclass PoseDetectionUtils {\n  constructor() {\n    this.pose = null;\n    this.isInitialized = false;\n  // Per-exercise state to avoid cross-contamination between different exercises\n  // Structure: { <mode>: { state: 'up'|'down'|'neutral'|..., count: number, extra... } }\n  this.perModeState = {};\n  const initMode = (mode) => ({ state: 'up', count: 0 });\n  this.perModeState['pushups'] = initMode('pushups');\n  this.perModeState['squats'] = initMode('squats');\n  this.perModeState['lunges'] = initMode('lunges');\n  this.perModeState['burpees'] = initMode('burpees');\n  this.perModeState['mountainclimbers'] = { state: 'neutral', count: 0, _lastLeftKneeY: null, _lastRightKneeY: null, _climberState: 'neutral', _lastClimberTime: 0 };\n  this.perModeState['highknees'] = { state: 'down', count: 0 };\n    this.postureStatus = 'unknown'; // correct, incorrect, unknown\n    this.lastWarningTime = 0;\n    this.videoDimensionsLogged = false;\n    // Exercise mode and timing\n    this.exerciseMode = 'pushups'; // 'pushups' | 'plank' | 'squats' | 'lunges'\n    this.accumulatedCorrectMs = 0;\n    this.timerRunning = false;\n    this.startCorrectTimestampMs = 0;\n    this.onPushupCount = null;\n    this.onPostureChange = null;\n    this.onFormFeedback = null;\n    this.onTimeUpdate = null; // for plank seconds updates\n  }\n\n  setExerciseMode(mode) {\n    // ensure perModeState exists for the selected mode\n    if (!this.perModeState[this.exerciseMode]) {\n      this.perModeState[this.exerciseMode] = { state: 'up', count: 0 };\n    }\n    const normalized = String(mode || '').toLowerCase();\n    if (normalized === 'plank') this.exerciseMode = 'plank';\n    else if (normalized === 'squats' || normalized === 'squat') this.exerciseMode = 'squats';\n    else if (normalized === 'lunges' || normalized === 'lunge') this.exerciseMode = 'lunges';\n    else if (normalized === 'burpees' || normalized === 'burpee') this.exerciseMode = 'burpees';\n    else if (normalized.includes('mountain') || normalized.includes('climber')) this.exerciseMode = 'mountainclimbers';\n    else if (normalized.includes('high') && normalized.includes('knees')) this.exerciseMode = 'highknees';\n    else this.exerciseMode = 'pushups';\n  }\n\n  // Initialize MediaPipe Pose\n  async initialize() {\n    try {\n      console.log('üöÄ Initializing MediaPipe Pose...');\n      \n      // Wait for MediaPipe to load if not ready\n      if (!window.Pose) {\n        console.warn('MediaPipe Pose not loaded yet, waiting...');\n        // Wait up to 10 seconds for MediaPipe to load\n        let attempts = 0;\n        while (!window.Pose && attempts < 50) {\n          await new Promise(resolve => setTimeout(resolve, 200));\n          attempts++;\n          if (attempts % 10 === 0) {\n            console.log(`Still waiting for MediaPipe... (${attempts * 200}ms)`);\n          }\n        }\n        \n        if (!window.Pose) {\n          console.error('MediaPipe Pose failed to load after waiting');\n          return false;\n        }\n      }\n      \n      console.log('‚úÖ MediaPipe Pose found in window object');\n\n      this.pose = new window.Pose({\n        locateFile: (file) => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n        }\n      });\n\n      const config = window.MediaPipeConfig?.POSE_CONFIG || {\n        modelComplexity: 0,\n        smoothLandmarks: true,\n        enableSegmentation: false,\n        smoothSegmentation: false,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      };\n\n      this.pose.setOptions(config);\n      this.pose.onResults(this.onResults.bind(this));\n      \n      this.isInitialized = true;\n      console.log('MediaPipe Pose initialized successfully');\n      return true;\n    } catch (error) {\n      console.error('Failed to initialize MediaPipe Pose:', error);\n      return false;\n    }\n  }\n\n  // Process video frame\n  async processFrame(videoElement) {\n    if (!this.isInitialized || !this.pose) {\n      console.log('‚ùå Pose not initialized or missing');\n      return null;\n    }\n\n    try {\n      // Only log occasionally to avoid spam\n      if (Math.random() < 0.05) {\n        console.log('üìπ Processing frame...');\n      }\n      \n      // Check if video dimensions are reasonable\n      if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {\n        if (Math.random() < 0.1) {\n          console.log('‚è≥ Video dimensions not ready yet');\n        }\n        return;\n      }\n      \n      // Log video dimensions only once per session\n      if (!this.videoDimensionsLogged) {\n        console.log(`üìè Video dimensions: ${videoElement.videoWidth}x${videoElement.videoHeight}`);\n        this.videoDimensionsLogged = true;\n      }\n      \n      // Allow larger videos but with a reasonable limit\n      const maxWidth = 1920;\n      const maxHeight = 1080;\n      if (videoElement.videoWidth > maxWidth || videoElement.videoHeight > maxHeight) {\n        console.log('‚ö†Ô∏è Video too large (>1920x1080), skipping frame');\n        return;\n      }\n      \n      await this.pose.send({ image: videoElement });\n    } catch (error) {\n      if (error.message?.includes('memory access out of bounds')) {\n        console.warn('üîÑ Memory error, skipping frame');\n        return;\n      }\n      console.error('Error processing frame:', error);\n    }\n  }\n\n  // Handle pose detection results\n  onResults(results) {\n    console.log('üéØ onResults called!', results.poseLandmarks ? `Found ${results.poseLandmarks.length} landmarks` : 'No landmarks');\n    \n    // Store results for drawing\n    this.lastResults = results;\n    \n    if (!results.poseLandmarks) {\n      this.postureStatus = 'unknown';\n      if (this.onPostureChange) {\n        this.onPostureChange('unknown', null);\n      }\n      // Stop plank timer if running\n      if (this.timerRunning) {\n        this.accumulatedCorrectMs += Date.now() - this.startCorrectTimestampMs;\n        this.timerRunning = false;\n        this.startCorrectTimestampMs = 0;\n        if (this.onTimeUpdate) {\n          this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n        }\n      }\n      return;\n    }\n\n    const landmarks = results.poseLandmarks;\n    \n    // Evaluate posture for the current exercise using the unified checker.\n    // Use a short consecutive-frame smoothing window to avoid brief spikes flipping posture state\n    const isPostureCorrectInstant = this.checkBackAlignment(landmarks);\n\n    // Initialize counters if missing\n    if (this._postureGoodCount == null) this._postureGoodCount = 0;\n    if (this._postureBadCount == null) this._postureBadCount = 0;\n\n    if (isPostureCorrectInstant) {\n      this._postureGoodCount += 1;\n      this._postureBadCount = 0;\n    } else {\n      this._postureBadCount += 1;\n      this._postureGoodCount = 0;\n    }\n\n  const POSTURE_GOOD_FRAMES = window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_GOOD_FRAMES ?? 3;\n  // For squats we require more consecutive bad frames before flipping to 'incorrect' to avoid\n  // false positives during normal descent. Default to 6 for squats, 4 otherwise.\n  const POSTURE_BAD_FRAMES = (this.exerciseMode === 'squats') ? (window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_BAD_FRAMES ?? 6) : (window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_BAD_FRAMES ?? 4);\n\n    let smoothedStatus = this.postureStatus;\n    if (this._postureGoodCount >= POSTURE_GOOD_FRAMES) {\n      smoothedStatus = 'correct';\n    } else if (this._postureBadCount >= POSTURE_BAD_FRAMES) {\n      smoothedStatus = 'incorrect';\n    }\n\n    // For squats we don't want to show poor/incorrect posture feedback ‚Äî treat as correct.\n    if (this.exerciseMode === 'squats') {\n      smoothedStatus = 'correct';\n    }\n\n    if (smoothedStatus !== this.postureStatus) {\n      this.postureStatus = smoothedStatus;\n      if (this.onPostureChange) this.onPostureChange(this.postureStatus, landmarks);\n    }\n\n    // If posture is incorrect for strength/technique exercises, warn and normally skip counting.\n    // However, allow deep squat descents (hip below knee) to proceed to the squat counter so\n    // counting can occur if legs are stable. The squat counter itself still enforces stability\n    // and collapse checks.\n    const cardioExercises = ['mountainclimbers', 'highknees'];\n\n    // Compute hip/knee centers to detect a deep squat descent (hip below knee)\n    const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n    const leftHip = landmarks[cfg.LEFT_HIP || 23];\n    const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n    const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n    const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n    const hipCenter = leftHip && rightHip ? { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 } : null;\n    const kneeCenter = leftKnee && rightKnee ? { x: (leftKnee.x + rightKnee.x) / 2, y: (leftKnee.y + rightKnee.y) / 2 } : null;\n    const hipBelowKnee = hipCenter && kneeCenter ? (hipCenter.y > kneeCenter.y) : false;\n\n  // Do not emit posture warnings or block counting for squats; allow squat-specific logic to handle counting.\n  if (this.postureStatus !== 'correct' && !cardioExercises.includes(this.exerciseMode) && this.exerciseMode !== 'squats') {\n      const currentTime = Date.now();\n      const cooldown = window.MediaPipeConfig?.PLANK_CONFIG?.WARNING_COOLDOWN || 2000;\n\n      if (currentTime - this.lastWarningTime > cooldown) {\n        this.playWarningSound();\n        this.lastWarningTime = currentTime;\n\n        if (this.onFormFeedback) {\n          this.onFormFeedback({\n            message: \"Dangerous posture - straighten your back!\",\n            type: \"warning\",\n            timestamp: currentTime\n          });\n        }\n      }\n\n      // Stop plank timer while incorrect\n      if (this.exerciseMode === 'plank' && this.timerRunning) {\n        this.accumulatedCorrectMs += currentTime - this.startCorrectTimestampMs;\n        this.timerRunning = false;\n        this.startCorrectTimestampMs = 0;\n        if (this.onTimeUpdate) {\n          this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n        }\n      }\n\n      // Do not proceed to rep counting when posture is incorrect for non-cardio exercises\n      return;\n    }\n\n    // Posture is correct\n    if (this.exerciseMode === 'plank') {\n      const now = Date.now();\n      if (!this.timerRunning) {\n        this.startCorrectTimestampMs = now;\n        this.timerRunning = true;\n      }\n      const totalMs = this.accumulatedCorrectMs + (now - (this.startCorrectTimestampMs || now));\n      const seconds = Math.floor(totalMs / 1000);\n      if (this.onTimeUpdate) this.onTimeUpdate(seconds);\n      return;\n    }\n\n    // Count reps depending on mode\n      if (this.exerciseMode === 'squats') {\n        this.updateSquatCounter(landmarks);\n      } else if (this.exerciseMode === 'lunges') {\n        this.updateLungesCounter(landmarks);\n      } else if (this.exerciseMode === 'burpees') {\n        this.updateBurpeesCounter(landmarks);\n      } else if (this.exerciseMode === 'mountainclimbers') {\n        this.updateMountainClimbersCounter(landmarks);\n      } else if (this.exerciseMode === 'highknees') {\n        this.updateHighKneesCounter(landmarks);\n      } else {\n        this.updatePushupCounter(landmarks);\n      }\n  }\n\n  // Calculate angle between three points\n  calculateAngle(point1, point2, point3) {\n    const radians = Math.atan2(point3.y - point2.y, point3.x - point2.x) - \n                   Math.atan2(point1.y - point2.y, point1.x - point2.x);\n    let angle = Math.abs(radians * 180.0 / Math.PI);\n    \n    if (angle > 180.0) {\n      angle = 360 - angle;\n    }\n    \n    return angle;\n  }\n\n  // Detect stable push-up start pose: torso roughly horizontal and ankles visible (proxy for being on toes)\n  isPushupStartPose(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftAnkle) || !vis(rightAnkle)) {\n        return false;\n      }\n\n      const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;\n      const hipCenterY = (leftHip.y + rightHip.y) / 2;\n\n      // torso vertical difference small -> near horizontal\n      const torsoDy = Math.abs(shoulderCenterY - hipCenterY);\n      const THRESH = window.MediaPipeConfig?.PUSHUP_CONFIG?.START_TORSO_DY ?? 0.08;\n      if (torsoDy > THRESH) return false;\n\n      // ankles visible and reasonably below hips (on toes) as an extra proxy\n      const ankleBelowHip = ((leftAnkle.y + rightAnkle.y) / 2) > hipCenterY;\n      if (!ankleBelowHip) return false;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Detect stable squat start pose: standing upright with hips above knees and torso approximately vertical\n  isSquatStartPose(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      // Require shoulders, hips and knees for a reliable standing start pose.\n      // Ankles are optional because many webcams/cameras crop the feet.\n      if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftKnee) || !vis(rightKnee)) {\n        return false;\n      }\n\n      const hipY = (leftHip.y + rightHip.y) / 2;\n      const kneeY = (leftKnee.y + rightKnee.y) / 2;\n      // In normalized coordinates hip above knee when standing\n      const gap = kneeY - hipY; // positive when hip above knee\n  const GAP_MIN = window.MediaPipeConfig?.SQUAT_CONFIG?.START_HIP_KNEE_GAP ?? 0.01;\n      if (gap < GAP_MIN) return false;\n\n      // Torso should be roughly vertical when standing\n      const shoulderCenter = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n      const hipCenter = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      const dx = shoulderCenter.x - hipCenter.x;\n      const dy = shoulderCenter.y - hipCenter.y;\n      const angDeg = Math.abs(Math.atan2(dx, -dy) * 180 / Math.PI); // similar to torso tilt in squat logic\n  const MIN_VERT = window.MediaPipeConfig?.SQUAT_CONFIG?.STANDING_TORSO_MIN_DEG ?? 60;\n  const MAX_VERT = window.MediaPipeConfig?.SQUAT_CONFIG?.STANDING_TORSO_MAX_DEG ?? 120;\n      if (angDeg < MIN_VERT || angDeg > MAX_VERT) return false;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Check back alignment for posture\n  checkBackAlignment(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      \n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      // Require visibility. For plank allow side-view (one side) visibility; for other exercises require both sides for stability.\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      if (this.exerciseMode === 'plank') {\n        const leftSideOk = vis(leftShoulder) && vis(leftHip);\n        const rightSideOk = vis(rightShoulder) && vis(rightHip);\n        if (!leftSideOk && !rightSideOk) {\n          // Not enough landmarks to evaluate plank reliably\n          return false;\n        }\n      } else if (this.exerciseMode === 'pushups') {\n        // For push-ups we only require both shoulders and hips to be visible.\n        if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip)) {\n          return false;\n        }\n      } else {\n        // For other exercises require knees visible for stability\n        if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftKnee) || !vis(rightKnee)) {\n          return false;\n        }\n      }\n\n      // Calculate center points\n      const shoulderCenter = {\n        x: (leftShoulder.x + rightShoulder.x) / 2,\n        y: (leftShoulder.y + rightShoulder.y) / 2\n      };\n      \n      const hipCenter = {\n        x: (leftHip.x + rightHip.x) / 2,\n        y: (leftHip.y + rightHip.y) / 2\n      };\n      \n      const kneeCenter = {\n        x: (leftKnee.x + rightKnee.x) / 2,\n        y: (leftKnee.y + rightKnee.y) / 2\n      };\n      const ankleCenter = (vis(leftAnkle) && vis(rightAnkle)) ? {\n        x: (leftAnkle.x + rightAnkle.x) / 2,\n        y: (leftAnkle.y + rightAnkle.y) / 2\n      } : null;\n\n      // Vectors for straightness\n      const targetPoint = ankleCenter || kneeCenter;\n      const v1 = { x: shoulderCenter.x - hipCenter.x, y: shoulderCenter.y - hipCenter.y };\n      const v2 = targetPoint ? { x: targetPoint.x - hipCenter.x, y: targetPoint.y - hipCenter.y } : null;\n\n      let isGoodPosture = false;\n      if (this.exerciseMode === 'plank') {\n        // Plank: support both front-facing and side-view evaluation.\n        const cfg = window.MediaPipeConfig?.PLANK_CONFIG || {};\n\n        // Prefer side-view detection when one full side is visible (shoulder, hip, ankle)\n        const leftSideVisible = vis(leftShoulder) && vis(leftHip) && vis(leftAnkle);\n        const rightSideVisible = vis(rightShoulder) && vis(rightHip) && vis(rightAnkle);\n\n        if (leftSideVisible || rightSideVisible) {\n          const shoulder = leftSideVisible ? leftShoulder : rightShoulder;\n          const hip = leftSideVisible ? leftHip : rightHip;\n          const ankle = leftSideVisible ? leftAnkle : rightAnkle;\n\n          // Angle at hip between shoulder-hip-ankle: near 180¬∞ for a straight plank\n          const sideAngle = this.calculateAngle(shoulder, hip, ankle);\n          const minSideAngle = cfg.MIN_SIDE_ANGLE ?? 155; // degrees\n\n          isGoodPosture = sideAngle >= minSideAngle;\n\n          // optional knee check when both ankles visible\n          if (isGoodPosture && ankleCenter) {\n            const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n            const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n            const kneeMin = cfg.KNEE_MIN_DEG ?? 150;\n            const kneeOk = (leftKneeAngle >= kneeMin) && (rightKneeAngle >= kneeMin);\n            isGoodPosture = isGoodPosture && kneeOk;\n          }\n\n        } else {\n          // Fallback: use center-based straightness + orientation as before (front-facing)\n          let cosSim = -1;\n          if (v2) {\n            const mag1 = Math.hypot(v1.x, v1.y) || 1;\n            const mag2 = Math.hypot(v2.x, v2.y) || 1;\n            cosSim = (v1.x * v2.x + v1.y * v2.y) / (mag1 * mag2);\n          }\n          const absCos = Math.abs(Math.max(-1, Math.min(1, cosSim)));\n          const straightEnough = v2 ? (absCos >= (cfg.STRAIGHT_ABS_COS_MIN ?? 0.90)) : false;\n          const dx = shoulderCenter.x - hipCenter.x;\n          const dy = shoulderCenter.y - hipCenter.y;\n          const orientDeg = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);\n          const horizMax = cfg.HORIZ_MAX_DEG ?? 35;\n          const nearHorizontal = (orientDeg <= horizMax) || (orientDeg >= (180 - horizMax));\n          let kneeOk = true;\n          if (ankleCenter) {\n            const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n            const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n            const kneeMin = cfg.KNEE_MIN_DEG ?? 150;\n            kneeOk = (leftKneeAngle >= kneeMin) && (rightKneeAngle >= kneeMin);\n          }\n          isGoodPosture = straightEnough && nearHorizontal && kneeOk;\n        }\n\n      } else if (this.exerciseMode === 'squats') {\n        // Squats: accept normal descent (hip moving below knee) as a valid posture.\n        // Only flag 'BAD' when there's severe hip/back collapse (rounded back).\n        const scfg = window.MediaPipeConfig?.SQUAT_CONFIG || {};\n        const hipAngleLeft = this.calculateAngle(leftShoulder, leftHip, leftKnee);\n        const hipAngleRight = this.calculateAngle(rightShoulder, rightHip, rightKnee);\n        const hipAngle = (hipAngleLeft + hipAngleRight) / 2;\n        // Configurable thresholds\n        const hipAngleMin = scfg.HIP_ANGLE_MIN ?? 120; // generous minimum for 'upright' expectation\n        const collapseThreshold = scfg.HIP_ANGLE_COLLAPSE ?? 60; // below this -> collapsed (bad)\n        const dx = shoulderCenter.x - hipCenter.x;\n        const dy = shoulderCenter.y - hipCenter.y;\n        const torsoTiltDeg = Math.abs(Math.atan2(dx, -dy) * 180 / Math.PI);\n        const tiltMax = scfg.TORSO_TILT_MAX ?? 60;\n\n        // Determine hip vs knee vertical relationship (allow descent)\n        const hipBelowKnee = kneeCenter && (hipCenter.y > kneeCenter.y);\n\n        const collapseTiltMin = scfg.COLLAPSE_TILT_MIN ?? 70; // require significant forward rounding\n        if (hipAngle < collapseThreshold && torsoTiltDeg > collapseTiltMin) {\n          // Severe collapse (rounded back + low hip angle) ‚Äî definitely bad\n          isGoodPosture = false;\n        } else if (hipBelowKnee) {\n          // Normal squat descent ‚Äî accept as good (as long as collapse not detected)\n          isGoodPosture = true;\n        } else {\n          // Standing/upright checks: require reasonable hip angle and torso tilt\n          isGoodPosture = (hipAngle >= hipAngleMin) && (torsoTiltDeg <= tiltMax);\n        }\n      } else {\n        // Push-ups: prefer a dedicated horizontal-body check.\n        // Two modes: side view (ankles visible) -> use straight-line similarity as before.\n        // Front/angled view (no ankle visibility) -> check shoulder-hip orientation close to horizontal\n        const cfg = window.MediaPipeConfig?.PUSHUP_CONFIG || {};\n        const SIDE_ABS_COS_MIN = cfg.SIDE_ABS_COS_MIN ?? 0.82; // slightly more lenient\n        const HORIZ_TORSO_MAX_DEG = cfg.HORIZ_TORSO_MAX_DEG ?? 35; // allow more tilt\n\n        // If ankle center available assume side/diagonal view and use cos similarity\n        if (ankleCenter && v2) {\n          let cosSim = -1;\n          const mag1 = Math.hypot(v1.x, v1.y) || 1;\n          const mag2 = Math.hypot(v2.x, v2.y) || 1;\n          cosSim = (v1.x * v2.x + v1.y * v2.y) / (mag1 * mag2);\n          const absCos = Math.abs(Math.max(-1, Math.min(1, cosSim)));\n          isGoodPosture = absCos >= SIDE_ABS_COS_MIN;\n        } else {\n          // Fallback: check that shoulder-hip axis is near horizontal (small dy)\n          const dx = shoulderCenter.x - hipCenter.x;\n          const dy = shoulderCenter.y - hipCenter.y;\n          const angDeg = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);\n          // angle near 0 or near 180 -> horizontal\n          const nearHorizontal = (angDeg <= HORIZ_TORSO_MAX_DEG) || (angDeg >= (180 - HORIZ_TORSO_MAX_DEG));\n          // Also ensure it's not standing (i.e., torso nearly vertical)\n          const nearVertical = (angDeg >= 90 - 20 && angDeg <= 90 + 20);\n          isGoodPosture = nearHorizontal && !nearVertical;\n        }\n      }\n\n      console.log(`üèÉ Posture(${this.exerciseMode}): ${isGoodPosture ? 'GOOD' : 'BAD'}`);\n      \n      return isGoodPosture;\n    } catch (error) {\n      console.error('Error checking back alignment:', error);\n      return false;\n    }\n  }\n\n  // Update push-up counter\n  updatePushupCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const pushupConfig = window.MediaPipeConfig?.PUSHUP_CONFIG || {};\n      \n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const leftElbow = landmarks[config.LEFT_ELBOW || 13];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const rightElbow = landmarks[config.RIGHT_ELBOW || 14];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n\n      if (!leftShoulder || !leftElbow || !leftWrist || !rightShoulder || !rightElbow || !rightWrist || !leftHip || !rightHip) {\n        return;\n      }\n\n      // Calculate elbow angles\n      const leftElbowAngle = this.calculateAngle(leftShoulder, leftElbow, leftWrist);\n      const rightElbowAngle = this.calculateAngle(rightShoulder, rightElbow, rightWrist);\n      const avgElbowAngle = (leftElbowAngle + rightElbowAngle) / 2;\n\n      // Average shoulder position (for height detection)\n      const avgShoulderY = (leftShoulder.y + rightShoulder.y) / 2;\n\n      const downThreshold = pushupConfig.ELBOW_ANGLE_DOWN || 95;\n      const upThreshold = pushupConfig.ELBOW_ANGLE_UP || 155;\n      const shoulderHeightThreshold = pushupConfig.SHOULDER_HEIGHT_DOWN || 0.02;\n\n      // Push-up position: elbows bent OR shoulders close to ground\n      // Determine if user is likely standing: if shoulders are well above hips and torso vertical\n      const shoulderHipDy = Math.abs(((leftShoulder.y + rightShoulder.y) / 2) - ((leftHip.y + rightHip.y) / 2));\n      const torsoVerticalThreshold = pushupConfig.TORSO_VERTICAL_DY ?? 0.15; // if shoulders far above hips (normalized units)\n      const isLikelyStanding = shoulderHipDy < (pushupConfig.STANDING_DY_MIN ?? 0.05) ? false : ((leftShoulder.y + rightShoulder.y) / 2) < ((leftHip.y + rightHip.y) / 2) - (pushupConfig.STANDING_DY_MIN ?? 0.02);\n\n      // Baseline shoulder level (approx when 'up' state) ‚Äî store per-mode baseline\n      const pstate = this.perModeState['pushups'];\n      if (!pstate._baselineShoulderY) {\n        // initialize baseline to current shoulder Y when pose roughly horizontal\n        pstate._baselineShoulderY = avgShoulderY;\n      }\n\n      // If posture is not horizontal, don't update baseline; else slowly adapt baseline\n      if (Math.abs(((leftShoulder.y + rightShoulder.y) / 2) - ((leftHip.y + rightHip.y) / 2)) < 0.12) {\n        // adapt baseline slowly\n        pstate._baselineShoulderY = (pstate._baselineShoulderY * 0.95) + (avgShoulderY * 0.05);\n      }\n\n      // Push-up position: significant drop from baseline OR elbow angle threshold\n      const shoulderDrop = avgShoulderY - (pstate._baselineShoulderY || avgShoulderY);\n      const shoulderDropThreshold = pushupConfig.SHOULDER_DROP_THRESHOLD ?? 0.06; // normalized units\n      const pushupPosition = (avgElbowAngle <= downThreshold) || (shoulderDrop >= shoulderDropThreshold) || (avgShoulderY >= (1 - shoulderHeightThreshold));\n      \n      // Standing position: elbows straight and shoulders high (not horizontal)\n      const standingPosition = (avgElbowAngle >= upThreshold) && isLikelyStanding;\n\n      // In-position gating: require user to assume a stable push-up start pose before starting counting\n      if (!pstate._inPositionCount) pstate._inPositionCount = 0;\n      const inStart = this.isPushupStartPose(landmarks);\n      if (inStart) {\n        pstate._inPositionCount += 1;\n      } else {\n        pstate._inPositionCount = 0;\n      }\n\n      const REQUIRED_STABLE_FRAMES = window.MediaPipeConfig?.PUSHUP_CONFIG?.START_STABLE_FRAMES ?? 6; // ~6 frames\n      pstate._isInStartPose = pstate._inPositionCount >= REQUIRED_STABLE_FRAMES;\n\n      // Debounce reps: minimum ms between consecutive counts\n      const MIN_REP_MS = window.MediaPipeConfig?.PUSHUP_CONFIG?.MIN_REP_MS ?? 400;\n      if (!pstate._lastRepAt) pstate._lastRepAt = 0;\n      const now = Date.now();\n\n      // Only count if posture is correct and user is in start pose\n      if (this.postureStatus !== 'correct' || !pstate._isInStartPose) {\n        return; // do not count\n      }\n\n      if (pstate.state === 'up') {\n        if (pushupPosition && (now - pstate._lastRepAt) > MIN_REP_MS) {\n          pstate.state = 'down';\n          pstate.count += 1; // Count on descent\n          pstate._lastRepAt = now;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(pstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({ message: `Push-up ${pstate.count}`, type: 'success', timestamp: now });\n          }\n        }\n      } else if (pstate.state === 'down') {\n        // return to up when standingPosition or full extension detected\n        if (standingPosition || (!pushupPosition && avgElbowAngle >= upThreshold)) {\n          pstate.state = 'up'; // Reset state for next rep\n        }\n      }\n    } catch (error) {\n      console.error('Error updating push-up counter:', error);\n    }\n  }\n\n  // Update squat counter\n  updateSquatCounter(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const scfg = window.MediaPipeConfig?.SQUAT_CONFIG || {};\n\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle || !leftShoulder || !rightShoulder) return;\n\n      // Check if user is in horizontal position (like pushup) - show warning but DO NOT count if so\n      const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;\n      const hipCenterY = (leftHip.y + rightHip.y) / 2;\n      const head = landmarks[cfg.NOSE || 0];\n      const torsoDy = Math.abs(shoulderCenterY - hipCenterY);\n      const HORIZONTAL_THRESHOLD = 0.08; // Same threshold as pushup detection\n      // Check if head is at same y level as hips (head down, body horizontal)\n      const headHipDy = Math.abs((head?.y ?? 0) - hipCenterY);\n      const HEAD_HIP_HORIZONTAL_THRESHOLD = 0.10; // If head and hip are close in y, likely horizontal\n      let isHorizontalLikePushup = false;\n      if (torsoDy <= HORIZONTAL_THRESHOLD && headHipDy <= HEAD_HIP_HORIZONTAL_THRESHOLD) {\n        isHorizontalLikePushup = true;\n        // Optional: show warning\n        if (this.onFormFeedback) {\n          this.onFormFeedback({ \n            message: 'Ÿàÿ∂ÿπ ÿßŸÑÿ¨ÿ≥ŸÖ ÿ£ŸÅŸÇŸäÿå ŸÑŸÜ Ÿäÿ™ŸÖ ÿßŸÑÿπÿØ ÿ•ŸÑÿß ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ŸÉŸàÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠', \n            type: 'warning', \n            timestamp: Date.now() \n          });\n        }\n      }\n\n      // Check if hands are on the ground (like pushup)\n      const leftWrist = landmarks[cfg.LEFT_WRIST || 15];\n      const rightWrist = landmarks[cfg.RIGHT_WRIST || 16];\n      const leftFoot = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightFoot = landmarks[cfg.RIGHT_ANKLE || 28];\n      // Consider hands on ground if both wrists are at or below the level of the ankles (with small margin)\n      const HANDS_ON_GROUND_THRESHOLD = 0.07; // allow small margin\n      let handsOnGround = false;\n      if (leftWrist && rightWrist && leftFoot && rightFoot) {\n        const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n        const avgFootY = (leftFoot.y + rightFoot.y) / 2;\n        if (avgWristY >= avgFootY - HANDS_ON_GROUND_THRESHOLD) {\n          handsOnGround = true;\n          if (this.onFormFeedback) {\n            this.onFormFeedback({\n              message: 'ÿßŸÑŸäÿØŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ÿ±ÿ∂ÿå ŸÑŸÜ Ÿäÿ™ŸÖ ÿßŸÑÿπÿØ ÿ•ŸÑÿß ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ŸÉŸàÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠',\n              type: 'warning',\n              timestamp: Date.now()\n            });\n          }\n        }\n      }\n\n      // Average sides for stability\n      const hip = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      const knee = { x: (leftKnee.x + rightKnee.x) / 2, y: (leftKnee.y + rightKnee.y) / 2 };\n      const ankle = { x: (leftAnkle.x + rightAnkle.x) / 2, y: (leftAnkle.y + rightAnkle.y) / 2 };\n      const shoulder = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n\n      // Knee angle using hip-knee-ankle\n      const kneeAngleLeft = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const kneeAngleRight = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n      const avgKneeAngle = (kneeAngleLeft + kneeAngleRight) / 2;\n\n      // Check leg stability - both legs should be moving together (not one leg down)\n      const leftKneeY = leftKnee.y;\n      const rightKneeY = rightKnee.y;\n      const kneeHeightDiff = Math.abs(leftKneeY - rightKneeY);\n      const LEG_STABILITY_THRESHOLD = 0.05; // Maximum difference between left and right knee heights\n      \n      const legsStable = kneeHeightDiff <= LEG_STABILITY_THRESHOLD;\n      \n      // Check if knees are bending (squatting down)\n      const kneesBending = avgKneeAngle < 120; // Knees bent when angle is less than 120 degrees\n\n      // Count based on hip position (lower back points)\n      const hipY = hip.y; // Y position of hips (lower = deeper)\n      const kneeY = knee.y; // Y position of knees\n      \n      // Hip goes below knee level = deep squat\n      const hipBelowKnee = hipY > kneeY;\n      // Hip goes back up above knee level = standing\n      const hipAboveKnee = hipY < kneeY;\n      \n      // State machine: count when hip goes down below knee level (use per-mode state)\n      const stateObj = this.perModeState['squats'];\n\n      // Debug logging\n      console.log('üîç Squat Debug:', {\n        legsStable,\n        kneesBending,\n        avgKneeAngle,\n        kneeHeightDiff,\n        hipBelowKnee,\n        hipAboveKnee,\n        state: stateObj.state,\n        count: stateObj.count\n      });\n\n      // Simplified squat counting: count when hips go below knees with stable legs\n      const MIN_REP_MS = window.MediaPipeConfig?.SQUAT_CONFIG?.MIN_REP_MS ?? 500;\n      if (!stateObj._lastRepAt) stateObj._lastRepAt = 0;\n      const now = Date.now();\n\n      if (stateObj.state === 'up') {\n        // Count if hips go below knees and legs are stable, and NOT in horizontal position or hands on ground\n        if (hipBelowKnee && legsStable && !isHorizontalLikePushup && !handsOnGround && (now - stateObj._lastRepAt) > MIN_REP_MS) {\n          stateObj.state = 'down';\n          stateObj.count += 1;\n          stateObj._lastRepAt = now;\n          console.log('üéØ Squat counted! Count:', stateObj.count);\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(stateObj.count);\n        } else {\n          // Debug why counting didn't happen\n          if (!hipBelowKnee) {\n            console.log('‚ùå Not counting: Hips not below knees');\n          } else if (!legsStable) {\n            console.log('‚ùå Not counting: Legs not stable (one leg down)');\n          } else if (isHorizontalLikePushup) {\n            console.log('‚ùå Not counting: Body is horizontal like pushup');\n          } else if (handsOnGround) {\n            console.log('‚ùå Not counting: Hands are on the ground');\n          } else if ((now - stateObj._lastRepAt) <= MIN_REP_MS) {\n            console.log('‚ùå Not counting: Too soon since last rep');\n          }\n        }\n      } else if (stateObj.state === 'down') {\n        if (hipAboveKnee) {\n          stateObj.state = 'up';\n          console.log('‚¨ÜÔ∏è Squat state changed to UP');\n        }\n      }\n    } catch (error) {\n      console.error('Error updating squat counter:', error);\n    }\n  }\n\n  // Update lunges counter\n  updateLungesCounter(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const lcfg = window.MediaPipeConfig?.LUNGES_CONFIG || {};\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n      \n      // Check if hands are on the ground (like pushup) - don't count lunges if hands on ground\n      const leftWrist = landmarks[cfg.LEFT_WRIST || 15];\n      const rightWrist = landmarks[cfg.RIGHT_WRIST || 16];\n      const leftFoot = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightFoot = landmarks[cfg.RIGHT_ANKLE || 28];\n      const HANDS_ON_GROUND_THRESHOLD = 0.07;\n      let handsOnGround = false;\n      if (leftWrist && rightWrist && leftFoot && rightFoot) {\n        const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n        const avgFootY = (leftFoot.y + rightFoot.y) / 2;\n        if (avgWristY >= avgFootY - HANDS_ON_GROUND_THRESHOLD) {\n          handsOnGround = true;\n        }\n      }\n      \n      // Average hip position\n      const hip = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      // Calculate knee angles\n      const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n      // Determine which leg is front (more bent knee) - allow both legs to be counted\n      const leftKneeBent = leftKneeAngle < rightKneeAngle;\n      const frontKnee = leftKneeBent ? leftKnee : rightKnee;\n      const backKnee = leftKneeBent ? rightKnee : leftKnee;\n      const frontKneeAngle = leftKneeBent ? leftKneeAngle : rightKneeAngle;\n      const backKneeAngle = leftKneeBent ? rightKneeAngle : leftKneeAngle;\n      \n      // Also check the opposite leg position (for alternating lunges)\n      const rightKneeBent = rightKneeAngle < leftKneeAngle;\n      const altFrontKnee = rightKneeBent ? rightKnee : leftKnee;\n      const altBackKnee = rightKneeBent ? leftKnee : rightKnee;\n      const altFrontKneeAngle = rightKneeBent ? rightKneeAngle : leftKneeAngle;\n      const altBackKneeAngle = rightKneeBent ? leftKneeAngle : rightKneeAngle;\n      // Hip position relative to front knee\n      const hipBelowFrontKnee = hip.y > frontKnee.y;\n      // Lunge position based on the image: one leg forward, body leaning forward, back knee close to ground\n      const KNEE_Y_DIFF_THRESHOLD = 0.06; // ŸÅÿ±ŸÇ Ÿàÿßÿ∂ÿ≠ ÿ®ŸäŸÜ ÿßŸÑÿ±ŸÉÿ®ÿ™ŸäŸÜ (ÿ±ÿ¨ŸÑ ŸÑŸÑÿ£ŸÖÿßŸÖ) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const BACK_KNEE_ANGLE_THRESHOLD = 120; // back knee bent (close to ground) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const FRONT_KNEE_ANGLE_THRESHOLD = 100; // front knee bent (stable support) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const HIP_FORWARD_THRESHOLD = 0.08; // hip leaning forward over front leg - ÿ™Ÿàÿ≥Ÿäÿπ\n      \n      const kneeYDiff = Math.abs(leftKnee.y - rightKnee.y);\n      const oneLegForward = kneeYDiff > KNEE_Y_DIFF_THRESHOLD;\n      \n      // Check first leg position (left leg forward)\n      const backKneeBent = backKneeAngle < BACK_KNEE_ANGLE_THRESHOLD;\n      const frontKneeBent = frontKneeAngle < FRONT_KNEE_ANGLE_THRESHOLD;\n      const frontHip = leftKneeBent ? leftHip : rightHip;\n      const frontAnkle = leftKneeBent ? leftAnkle : rightAnkle;\n      const hipForwardLean = Math.abs(frontHip.x - frontAnkle.x) < HIP_FORWARD_THRESHOLD;\n      const lungePosition1 = oneLegForward && backKneeBent && frontKneeBent && hipForwardLean;\n      \n      // Check second leg position (right leg forward)\n      const altBackKneeBent = altBackKneeAngle < BACK_KNEE_ANGLE_THRESHOLD;\n      const altFrontKneeBent = altFrontKneeAngle < FRONT_KNEE_ANGLE_THRESHOLD;\n      const altFrontHip = rightKneeBent ? rightHip : leftHip;\n      const altFrontAnkle = rightKneeBent ? rightAnkle : leftAnkle;\n      const altHipForwardLean = Math.abs(altFrontHip.x - altFrontAnkle.x) < HIP_FORWARD_THRESHOLD;\n      const lungePosition2 = oneLegForward && altBackKneeBent && altFrontKneeBent && altHipForwardLean;\n      \n      // Either leg position counts as a lunge\n      const lungePosition = lungePosition1 || lungePosition2;\n      // Standing position: both knees straight\n      const standingPosition = (frontKneeAngle >= 160) && (backKneeAngle >= 150);\n      // Simple counting: count immediately when going down (like squats)\n      const lstate = this.perModeState['lunges'];\n      if (lstate.state === 'up') {\n        if (!handsOnGround && lungePosition) {\n          lstate.state = 'down';\n          lstate.count += 1; // Count immediately on descent\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(lstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({ message: `Lunge ${lstate.count}`, type: 'success', timestamp: Date.now() });\n          }\n        }\n      } else if (lstate.state === 'down') {\n        if (standingPosition) {\n          lstate.state = 'up'; // Reset state for next rep\n        }\n      }\n    } catch (error) {\n      console.error('Error updating lunges counter:', error);\n    }\n  }\n\n  // Add Burpees counter\n  // Update mountain climbers counter\n  updateMountainClimbersCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      \n      // Get key body points\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n\n      // Calculate vertical distances between knees and hips\n      const leftKneeToHipY = Math.abs(leftKnee.y - leftHip.y);\n      const rightKneeToHipY = Math.abs(rightKnee.y - rightHip.y);\n\n      // Initialize states if needed\n      if (!this._lastLeftKneeY) this._lastLeftKneeY = leftKnee.y;\n      if (!this._lastRightKneeY) this._lastRightKneeY = rightKnee.y;\n      if (!this._climberState) this._climberState = 'neutral';\n      if (!this._lastClimberTime) this._lastClimberTime = Date.now();\n      \n      const KNEE_THRESHOLD = 0.05; // How far the knee needs to move\n      const MIN_REP_TIME = 250; // Minimum time between reps (ms)\n      const currentTime = Date.now();\n\n      // Calculate knee movements\n      const leftKneeMove = leftKnee.y - this._lastLeftKneeY;\n      const rightKneeMove = rightKnee.y - this._lastRightKneeY;\n\n      // Check for significant knee movements in opposite directions\n      const isAlternating = (leftKneeMove > KNEE_THRESHOLD && rightKneeMove < -KNEE_THRESHOLD) ||\n                           (leftKneeMove < -KNEE_THRESHOLD && rightKneeMove > KNEE_THRESHOLD);\n\n      // State machine for counting alternating leg movements\n      const cmode = this.perModeState['mountainclimbers'];\n      if (cmode._climberState === 'neutral') {\n        if (isAlternating && (currentTime - cmode._lastClimberTime > MIN_REP_TIME)) {\n          cmode._climberState = 'moving';\n          cmode._lastClimberTime = currentTime;\n          // Count the rep\n          cmode.count += 1;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(cmode.count);\n          if (this.onFormFeedback) {\n            const leg = leftKneeMove > rightKneeMove ? 'Left' : 'Right';\n            this.onFormFeedback({\n              message: `${leg} knee drive - Rep ${cmode.count}`,\n              type: 'success',\n              timestamp: currentTime\n            });\n          }\n        }\n      } else if (cmode._climberState === 'moving') {\n        if (!isAlternating) {\n          cmode._climberState = 'neutral';\n        }\n      }\n\n      // Update last positions\n      cmode._lastLeftKneeY = leftKnee.y;\n      cmode._lastRightKneeY = rightKnee.y;\n\n      // Form feedback for incorrect movement\n      if (Math.abs(leftHip.y - rightHip.y) > 0.1) { // Hips not level\n        if (this.onFormFeedback && Math.random() < 0.1) {\n          this.onFormFeedback({\n            message: \"Keep hips level!\",\n            type: \"warning\",\n            timestamp: currentTime\n          });\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating mountain climbers counter:', error);\n    }\n  }\n\n  updateBurpeesCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      // ŸÜŸÇÿßÿ∑ ÿßŸÑÿ±ÿ£ÿ≥ ŸàÿßŸÑŸäÿØŸäŸÜ\n      const nose = landmarks[config.NOSE || 0];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftIndex = landmarks[config.LEFT_INDEX || 19];\n      const rightIndex = landmarks[config.RIGHT_INDEX || 20];\n      if (!nose || !leftWrist || !rightWrist) return;\n      // ÿ£ÿπŸÑŸâ ŸÜŸÇÿ∑ÿ© ŸÑŸÑÿ±ÿ£ÿ≥\n      const headY = nose.y;\n      // ÿ£ÿπŸÑŸâ ŸÜŸÇÿ∑ÿ© ŸÑŸÑŸäÿØ ÿ£Ÿà ÿßŸÑÿ£ÿµÿßÿ®ÿπ\n      const leftHandY = leftIndex ? leftIndex.y : leftWrist.y;\n      const rightHandY = rightIndex ? rightIndex.y : rightWrist.y;\n      // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸäÿØŸäŸÜ ÿ£Ÿà ÿßŸÑÿ£ÿµÿßÿ®ÿπ ÿ£ÿπŸÑŸâ ŸÖŸÜ ÿßŸÑÿ±ÿ£ÿ≥ (ÿ£ŸÇŸÑ ŸÅŸä ŸÇŸäŸÖÿ© y)\n      const handsAboveHead = (leftHandY < headY && rightHandY < headY);\n      // ŸÖŸÜÿ∑ŸÇ ÿßŸÑÿπÿØ\n      if (!this._burpeeState) this._burpeeState = 'ready';\n      if (!this.perModeState['burpees']._burpeeState) this.perModeState['burpees']._burpeeState = 'ready';\n      const bstate = this.perModeState['burpees'];\n      if (bstate._burpeeState === 'ready') {\n        if (handsAboveHead) {\n          bstate._burpeeState = 'jumping';\n          bstate.count += 1;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(bstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({\n              message: `Burpee ${bstate.count} - Hands above head!`,\n              type: 'success',\n              timestamp: Date.now()\n            });\n          }\n        }\n      } else if (bstate._burpeeState === 'jumping') {\n        if (!handsAboveHead) {\n          bstate._burpeeState = 'ready';\n        }\n      }\n    } catch (error) {\n      console.error('Error updating burpees counter:', error);\n    }\n  }\n\n  updateHighKneesCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n\n      // Check if knee is at waist level or above (easier threshold)\n      const KNEE_HIP_THRESHOLD = 0.03; // Knee should be at waist level or above (easier)\n      const isLeftKneeHigh = (leftHip.y - leftKnee.y) > KNEE_HIP_THRESHOLD;\n      const isRightKneeHigh = (rightHip.y - rightKnee.y) > KNEE_HIP_THRESHOLD;\n\n      // Check if user is doing high knees movement (either leg up)\n      const isDoingHighKnees = isLeftKneeHigh || isRightKneeHigh;\n\n      // State machine for timing high knees (per-mode)\n      const hk = this.perModeState['highknees'];\n      if (!hk._highKneesState) hk._highKneesState = 'stopped';\n      if (!hk._startTime) hk._startTime = 0;\n      if (!hk._lastUpdateTime) hk._lastUpdateTime = 0;\n\n      const now = Date.now();\n      const MIN_MOVEMENT_INTERVAL = 100; // Minimum time between movements (ms)\n\n      if (hk._highKneesState === 'stopped') {\n        // Start timing when user begins high knees movement\n        if (isDoingHighKnees) {\n          hk._highKneesState = 'active';\n          hk._startTime = now;\n          hk._lastUpdateTime = now;\n          hk.count = 0; // Reset count\n          console.log('üèÉ High Knees started!');\n        }\n      } else if (hk._highKneesState === 'active') {\n        if (isDoingHighKnees) {\n          // Continue timing while user is doing high knees\n          hk._lastUpdateTime = now;\n          const elapsedSeconds = Math.floor((now - hk._startTime) / 1000);\n          \n          // Update count (in seconds) every second\n          if (elapsedSeconds > hk.count) {\n            hk.count = elapsedSeconds;\n            if (this.onPushupCount) this.onPushupCount(hk.count);\n            console.log(`‚è±Ô∏è High Knees: ${elapsedSeconds} seconds`);\n          }\n        } else {\n          // Check if user stopped for too long\n          const timeSinceLastMovement = now - hk._lastUpdateTime;\n          if (timeSinceLastMovement > 1500) { // Stop if no movement for 1.5 seconds\n            hk._highKneesState = 'stopped';\n            console.log('‚èπÔ∏è High Knees stopped!');\n          }\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating high knees counter:', error);\n    }\n  }\n\n  // Play warning sound\n  playWarningSound() {\n    try {\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n      \n      oscillator.connect(gainNode);\n      gainNode.connect(audioContext.destination);\n      \n      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);\n      oscillator.type = 'sine';\n      \n      gainNode.gain.setValueAtTime(0, audioContext.currentTime);\n      gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);\n      \n      oscillator.start(audioContext.currentTime);\n      oscillator.stop(audioContext.currentTime + 0.5);\n    } catch (error) {\n      console.error('Error playing warning sound:', error);\n    }\n  }\n\n  // Play success sound (pop.wav)\n  playSuccessSound() {\n    try {\n      const audio = new Audio('/assets/sounds/pop.wav');\n      audio.volume = 0.5; // Set volume to 50%\n      audio.play().catch(error => {\n        console.error('Error playing success sound:', error);\n      });\n    } catch (error) {\n      console.error('Error creating success sound:', error);\n    }\n  }\n\n  // Draw pose landmarks on canvas\n  drawPoseOverlay(canvasCtx, results, canvasWidth, canvasHeight) {\n    // Only log occasionally to avoid spam\n    if (Math.random() < 0.05) {\n      console.log('üé® Drawing pose overlay with', results.poseLandmarks?.length || 0, 'landmarks');\n    }\n\n    if (!results.poseLandmarks || !canvasCtx) {\n      return;\n    }\n\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n    // Draw landmarks\n    const landmarks = results.poseLandmarks;\n    let drawnLandmarks = 0;\n    \n    landmarks.forEach((landmark, index) => {\n      if (landmark.visibility && landmark.visibility > 0.5) {\n        const x = landmark.x * canvasWidth;\n        const y = landmark.y * canvasHeight;\n        \n        canvasCtx.beginPath();\n        canvasCtx.arc(x, y, 6, 0, 2 * Math.PI); // Bigger circles\n        canvasCtx.fillStyle = landmark.visibility > 0.7 ? '#10B981' : '#F59E0B';\n        canvasCtx.fill();\n        canvasCtx.strokeStyle = '#FFFFFF';\n        canvasCtx.lineWidth = 2;\n        canvasCtx.stroke();\n        drawnLandmarks++;\n      }\n    });\n\n    // Only log occasionally\n    if (Math.random() < 0.1) {\n      console.log('‚ú® Drew', drawnLandmarks, 'landmarks');\n    }\n\n    // Always use basic connections (more reliable)\n    this.drawBasicConnections(canvasCtx, landmarks, canvasWidth, canvasHeight);\n\n    canvasCtx.restore();\n  }\n\n  // Draw basic pose connections\n  drawBasicConnections(canvasCtx, landmarks, canvasWidth, canvasHeight) {\n    const connections = [\n      [11, 12], // shoulders\n      [11, 13], // left shoulder to elbow\n      [13, 15], // left elbow to wrist\n      [12, 14], // right shoulder to elbow\n      [14, 16], // right elbow to wrist\n      [11, 23], // left shoulder to hip\n      [12, 24], // right shoulder to hip\n      [23, 24], // hips\n      [23, 25], // left hip to knee\n      [25, 27], // left knee to ankle\n      [24, 26], // right hip to knee\n      [26, 28]  // right knee to ankle\n    ];\n\n    let drawnConnections = 0;\n    connections.forEach(([startIdx, endIdx]) => {\n      const startPoint = landmarks[startIdx];\n      const endPoint = landmarks[endIdx];\n\n      if (startPoint && endPoint && \n          startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n        canvasCtx.beginPath();\n        canvasCtx.moveTo(startPoint.x * canvasWidth, startPoint.y * canvasHeight);\n        canvasCtx.lineTo(endPoint.x * canvasWidth, endPoint.y * canvasHeight);\n        canvasCtx.strokeStyle = '#3B82F6';\n        canvasCtx.lineWidth = 3; // Thicker lines\n        canvasCtx.stroke();\n        drawnConnections++;\n      }\n    });\n    \n    // Only log occasionally\n    if (Math.random() < 0.02) {\n      console.log('‚úÖ Drawing completed!', drawnConnections, 'connections');\n    }\n  }\n\n  // Reset counter\n  resetCounter() {\n    // Reset only the counters/state for the currently selected exercise\n    const mode = this.exerciseMode;\n    if (this.perModeState && this.perModeState[mode]) {\n      this.perModeState[mode].count = 0;\n      this.perModeState[mode].state = 'up';\n      // reset mode-specific extras\n      if (mode === 'mountainclimbers') {\n        this.perModeState[mode]._lastLeftKneeY = null;\n        this.perModeState[mode]._lastRightKneeY = null;\n        this.perModeState[mode]._climberState = 'neutral';\n        this.perModeState[mode]._lastClimberTime = 0;\n      }\n      if (mode === 'burpees') {\n        this.perModeState[mode]._burpeeState = 'ready';\n      }\n    }\n    this.postureStatus = 'unknown';\n    // Reset plank timing\n    this.accumulatedCorrectMs = 0;\n    this.timerRunning = false;\n    this.startCorrectTimestampMs = 0;\n  }\n\n  // Get current stats\n  getStats() {\n    const mode = this.exerciseMode;\n    const stateObj = this.perModeState && this.perModeState[mode] ? this.perModeState[mode] : { count: 0, state: 'up' };\n    return {\n      count: stateObj.count || 0,\n      state: stateObj.state || 'up',\n      posture: this.postureStatus,\n      timeSec: Math.floor((this.accumulatedCorrectMs + (this.timerRunning ? (Date.now() - this.startCorrectTimestampMs) : 0)) / 1000)\n    };\n  }\n\n  // Get latest pose results for drawing\n  getLastResults() {\n    return this.lastResults;\n  }\n\n  // Set callback functions\n  setCallbacks({ onPushupCount, onPostureChange, onFormFeedback, onTimeUpdate }) {\n    this.onPushupCount = onPushupCount;\n    this.onPostureChange = onPostureChange;\n    this.onFormFeedback = onFormFeedback;\n    this.onTimeUpdate = onTimeUpdate;\n  }\n\n  // Cleanup\n  cleanup() {\n    if (this.pose) {\n      this.pose.close();\n      this.pose = null;\n    }\n    this.isInitialized = false;\n  }\n}\n\nexport default PoseDetectionUtils;\n"],"names":["PoseDetectionUtils","constructor","this","pose","isInitialized","perModeState","state","count","_lastLeftKneeY","_lastRightKneeY","_climberState","_lastClimberTime","postureStatus","lastWarningTime","videoDimensionsLogged","exerciseMode","accumulatedCorrectMs","timerRunning","startCorrectTimestampMs","onPushupCount","onPostureChange","onFormFeedback","onTimeUpdate","setExerciseMode","mode","normalized","String","toLowerCase","includes","initialize","_a","window","Pose","attempts","Promise","resolve","setTimeout","locateFile","file","config","MediaPipeConfig","POSE_CONFIG","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","setOptions","onResults","bind","error","processFrame","videoElement","Math","random","videoWidth","videoHeight","maxWidth","maxHeight","send","image","message","results","_b","_c","_d","_e","_f","_g","_h","_i","lastResults","poseLandmarks","Date","now","floor","landmarks","isPostureCorrectInstant","checkBackAlignment","_postureGoodCount","_postureBadCount","POSTURE_GOOD_FRAMES","SQUAT_CONFIG","POSTURE_BAD_FRAMES","smoothedStatus","cfg","POSE_LANDMARKS","leftHip","LEFT_HIP","rightHip","RIGHT_HIP","leftKnee","LEFT_KNEE","rightKnee","RIGHT_KNEE","hipCenter","x","y","kneeCenter","currentTime","cooldown","PLANK_CONFIG","WARNING_COOLDOWN","playWarningSound","type","timestamp","totalMs","seconds","updateSquatCounter","updateLungesCounter","updateBurpeesCounter","updateMountainClimbersCounter","updateHighKneesCounter","updatePushupCounter","calculateAngle","point1","point2","point3","radians","atan2","angle","abs","PI","isPushupStartPose","leftShoulder","LEFT_SHOULDER","rightShoulder","RIGHT_SHOULDER","leftAnkle","LEFT_ANKLE","rightAnkle","RIGHT_ANKLE","vis","p","visibility","shoulderCenterY","hipCenterY","torsoDy","PUSHUP_CONFIG","START_TORSO_DY","e","isSquatStartPose","hipY","kneeY","START_HIP_KNEE_GAP","shoulderCenter","dx","dy","angDeg","MIN_VERT","STANDING_TORSO_MIN_DEG","MAX_VERT","STANDING_TORSO_MAX_DEG","leftSideOk","rightSideOk","ankleCenter","targetPoint","v1","v2","isGoodPosture","leftSideVisible","rightSideVisible","shoulder","hip","ankle","sideAngle","MIN_SIDE_ANGLE","leftKneeAngle","rightKneeAngle","kneeMin","KNEE_MIN_DEG","cosSim","mag1","hypot","mag2","absCos","max","min","straightEnough","STRAIGHT_ABS_COS_MIN","orientDeg","horizMax","HORIZ_MAX_DEG","nearHorizontal","kneeOk","scfg","hipAngleLeft","hipAngle","hipAngleMin","HIP_ANGLE_MIN","collapseThreshold","HIP_ANGLE_COLLAPSE","torsoTiltDeg","tiltMax","TORSO_TILT_MAX","hipBelowKnee","collapseTiltMin","COLLAPSE_TILT_MIN","SIDE_ABS_COS_MIN","HORIZ_TORSO_MAX_DEG","pushupConfig","leftElbow","LEFT_ELBOW","leftWrist","LEFT_WRIST","rightElbow","RIGHT_ELBOW","rightWrist","RIGHT_WRIST","leftElbowAngle","avgElbowAngle","avgShoulderY","downThreshold","ELBOW_ANGLE_DOWN","upThreshold","ELBOW_ANGLE_UP","shoulderHeightThreshold","SHOULDER_HEIGHT_DOWN","shoulderHipDy","isLikelyStanding","TORSO_VERTICAL_DY","STANDING_DY_MIN","pstate","_baselineShoulderY","shoulderDrop","shoulderDropThreshold","SHOULDER_DROP_THRESHOLD","pushupPosition","standingPosition","_inPositionCount","REQUIRED_STABLE_FRAMES","START_STABLE_FRAMES","_isInStartPose","MIN_REP_MS","_lastRepAt","playSuccessSound","head","NOSE","HORIZONTAL_THRESHOLD","headHipDy","isHorizontalLikePushup","leftFoot","rightFoot","HANDS_ON_GROUND_THRESHOLD","handsOnGround","avgWristY","knee","kneeAngleLeft","leftKneeY","rightKneeY","kneeHeightDiff","legsStable","hipAboveKnee","stateObj","LUNGES_CONFIG","leftKneeBent","frontKnee","frontKneeAngle","backKneeAngle","rightKneeBent","altFrontKneeAngle","altBackKneeAngle","KNEE_Y_DIFF_THRESHOLD","BACK_KNEE_ANGLE_THRESHOLD","FRONT_KNEE_ANGLE_THRESHOLD","HIP_FORWARD_THRESHOLD","oneLegForward","backKneeBent","frontKneeBent","frontHip","frontAnkle","hipForwardLean","lungePosition1","altBackKneeBent","altFrontKneeBent","altFrontHip","altFrontAnkle","altHipForwardLean","lungePosition","lstate","KNEE_THRESHOLD","MIN_REP_TIME","leftKneeMove","rightKneeMove","isAlternating","cmode","leg","nose","leftIndex","LEFT_INDEX","rightIndex","RIGHT_INDEX","headY","leftHandY","rightHandY","handsAboveHead","_burpeeState","bstate","KNEE_HIP_THRESHOLD","isLeftKneeHigh","isRightKneeHigh","isDoingHighKnees","hk","_highKneesState","_startTime","_lastUpdateTime","elapsedSeconds","audioContext","AudioContext","webkitAudioContext","oscillator","createOscillator","gainNode","createGain","connect","destination","frequency","setValueAtTime","gain","linearRampToValueAtTime","exponentialRampToValueAtTime","start","stop","audio","Audio","volume","play","catch","drawPoseOverlay","canvasCtx","canvasWidth","canvasHeight","save","clearRect","forEach","landmark","index","beginPath","arc","fillStyle","fill","strokeStyle","lineWidth","stroke","drawBasicConnections","restore","startIdx","endIdx","startPoint","endPoint","moveTo","lineTo","resetCounter","getStats","posture","timeSec","getLastResults","setCallbacks","cleanup","close"],"mappings":"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"}